#include <iostream>
using namespace std;

class Point
{
public:
    Point(){x=0;y=0;}
    Point(int X,int Y):x(X),y(Y){}
    ~Point(){}
    void getpoint(){cout << "(" << x << ", " << y << ")" << endl;}
    friend Point & operator ++(Point &P);  //重载为友元
    friend Point & operator --(Point &P);
    friend Point operator ++(Point &P,int);
    friend Point operator --(Point &P,int);
private:
    int x;
    int y;
};

Point & operator ++(Point &P)
{
    ++P.x;
    ++P.y;
    return P;//返回形参自身
}

Point & operator --(Point &P)
{
    --P.x;
    --P.y;
    return P;//返回形参自身
}

Point operator ++(Point &P,int)  //后置++
{
    Point old=P;
    P.x++;
    P.y++;
    return old;//返回形参副本
}

Point operator --(Point &P,int)  //后置--
{
    Point old=P;
    P.x--;
    P.y--;
    return old;//返回形参副本
}

int main()
{
    Point po(0, 0);
    Point po1(2, 3);
    Point po2(1, 4);
    
    cout << "po: "; po.getpoint();
    cout << "po1: "; po1.getpoint();
    cout << "po2: "; po2.getpoint();
    cout << "_______________" << endl;
    
    cout<<"后置：po = po1++"<<endl;
    po = po1++;
    cout << "  po = "; po.getpoint();
    cout << "  po1 = "; po1.getpoint();
    
    cout<<"后置：po = po2--"<<endl;
    po = po2--;
    cout << "  po = "; po.getpoint();
    cout << "  po2 = "; po2.getpoint();
    cout << "_______________" << endl;
    
    cout<<"前置：po = ++po1"<<endl;
    po = ++po1;
    cout << "  po = "; po.getpoint();
    cout << "  po1 = "; po1.getpoint();
    
    cout<<"前置：po = --po2"<<endl;
    po = --po2;
    cout << "  po = "; po.getpoint();
    cout << "  po2 = "; po2.getpoint();
    
    return 0;
}

/*
 
 po: (0, 0)
 po1: (2, 3)
 po2: (1, 4)
 _______________
 后置：po = po1++
   po = (2, 3)
   po1 = (3, 4)
 后置：po = po2--
   po = (1, 4)
   po2 = (0, 3)
 _______________
 前置：po = ++po1
   po = (4, 5)
   po1 = (4, 5)
 前置：po = --po2
   po = (-1, 2)
   po2 = (-1, 2)
 
 利用哑元区分++--所在的位置，也就是区分前置还是后置，哑元用于后置

   重载运算符不能有二义性
 
运算符重载的函数一般地采用如下两种形式：成员函数形式 友元函数形式。这两种形式都可访问类中的私有成员。
 
可以用作重载的运算符:
算术运算符：+,-,*,/,%,++,--;
位操作运算符：&,|,~,^,＜＜,＞＞
逻辑运算符：!,&&,||;
比较运算符：＜,＞,＞=,＜=,==,!=;
赋值运算符：=,+=,-=,*=,/=,%=,&=,|=,^=,＜＜=,＞＞=;
其他运算符：[],(),-＞,,(逗号运算符),new,delete,new[],delete[],-＞*。
这些运算符不允许重载：.,.*,::,?:
 
 
 
1.运算符重载不会改变内置类型表达式中的运算符含义，只有在至少一个操作数是用户自定义类型的对象时，才有可能调用该类中重载的运算符。
2.运算符函数的参数个数取决于两个因素：
 1）运算符的操作数个数，即是一元运算符还是二元运算符。
 2）运算符函数是成员函数还是非成员函数。
 //类的成员运算符函数：
 this指向的对象被作为运算符的第一个操作数（左）
 一元运算符函数不需要提供函数
 二元运算符提供一个参数作为右操作数。
 //非成员运算符函数：
 一元运算符要提供一个类类型的参数。
 二元运算符需要提供两个参数分别作为左、右操作数，其中至少一个参数必须是类类型的。
 通常声明为类的友元，以便访问私有数据成员。
3.运算符重载的限制：
 1）不可以重载的运算符：作用域解析符（::）、成员选择符（.）成员指针间接引用符（.*）、条件运算符（?:）
 2）不能定义C++中没有的运算符。
 3）不建议重载的运算符：逻辑与（&&）、逻辑或（||）、逗号运算符（，）、取地址运算符（&）
 4）逻辑运算符和关系运算符应该返回bool值，算术运算符应该返回操作数类型的值，赋值运算符和复合赋值运算符返回左操作数对象的引用。
 5)赋值（=）、下标（[ ]）、函数调用（（））和成员函数访问箭头（->）运算符必须是成员函数。
4.常用运算符的重载
 1）输入运算符的函数原型：
 istream& operator>>(istream &in,type &t);//表示用in读入，type表示用户自定义类型，t是其对象。
 假设定义了一个Time类，类中有year、month、day成员，把运算符重载函数定义成Time类的友元：
 friend istream&operator>>(istream &is,Time &d);
 在类外：
 istream&operator>>(istream &is,Time &d)
 {
     is>>d.year>>d.month>>d.day;
     return is;
 }
 这样一来，在主函数里想要输入Time成员的时候，直接cin>>Time;就可以了，可以节省很多时间，同时也可以防止代码写得太多而遗漏某些成员。
 2）输出运算符的重载函数与输入运算符的类似。


  //当重载为成员函数时，双目运算符仅有一个参数
//对单目运算符，重载为成员函数时，不能再显式说明参数;
//重载为成员函数时，总时隐含了一个参数，该参数是this指针(this指针是指向调用该成员函数对象的指针)
//有些运行符不能重载为友元函数，它们是：=,(),[]和-＞。

 重载运算符 +/-*
//单目运算符最好被重载为成员
//双目运算符最好被重载为友元函数
//但是，有的双目运算符还是重载为成员函数为好，例如，赋值运算符。因为，它如果被重载为友元函数，将会出现与赋值语义不一致的地方

 重载运算符[]
//由于C语言的数组中并没有保存其大小，因此，不能对数组元素进行存取范围的检查，无法保证给数组动态赋值不会越界。为此，为该类定义重载运算符[]
//该函数只能带一个参数，不可带多个参数。不得重载为友元函数，必须是非static类的成员函数
//运行时动态指定大小可以不用运算符new和delete
//其大小不一定是一个常量
 
 函数调用运算符()
//函数调用运算符()可以被重载用于类的对象，这是创建一个可以传递任意数目参数的运算符函数
 
 运算符：
 
 单目就是这个运算符只对一个变量进行操作
 代表符号：!(逻辑非) ~（按位取反）++（自增）--（自减）
 举例：int a=1;a++;（第二句“a++”则只对a一个变量进行了操作）
 
 双目就是这个运算符对两个变量进行操作
 举例：int a=1,b=2,c;c=a+b;(第二句“c=a+b”则是对a,b两个变量进行了操作)
 
 三目就是这个运算符对三个变量进行操作
 代表符号： ?:(条件运算符)；int a = boolean ? b : c;

 */