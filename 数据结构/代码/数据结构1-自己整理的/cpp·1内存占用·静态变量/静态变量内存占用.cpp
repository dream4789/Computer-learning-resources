#include <iostream>
using namespace std;
class C1
{
private:
    int a;  //64 位系统下，整型占 4 字节
    int b;  //4
public:
    C1(int A,int B):a(A),b(B){cout<<this<<endl;}//0
}; //共占 8 字节

class C2
{
private:
    int a;//4
    int b;//4
    static int s;//静态不计算在栈内存
public:
    C2(int A,int B):a(A),b(B){cout<<this<<endl;}//0
    void setA(int A){a=A;} //0
    int getA() const //0
    {
        cout<<"访问实例成员的非静态函数"<< endl;
        //return s;//可以使用
        return a;
    }
    static int getS()  //0
    {
        cout<<"静态成员函数"<< endl;
        //return a;静态成员函数不能访问本类中的非静态成员
        return s;
    }
    /*
    int getS() const //0 //不合理的函数
    {
        cout<<"不访问实例成员的非静态函数"<< endl;
        //return s;不访问实例成员 s，是否可以和上一函数共存？
        return 2;
    }
    static int getA()  //0 //不合理的函数
    {
        cout<<"不访问实例成员的静态函数"<< endl;
        //return a;不访问实例成员 a，是否可以和上一函数共存（重载）？
        return 1;
    }
    
     */
};//共占 8 字节
int C2::s=0;
int main()
{
    C1 c1(1,1);
    C2 c2(2,2);
    C2 c22(22,22);//观察地址差
    cout<<"c1:"<<sizeof(c1)<<endl;
    cout<<"c2:"<<sizeof(c2)<<endl;
    
    //C2::getA();编译错："ambiguous call to overload function",似乎也含 this
    c2.getA();
    
    C2::getS();   //类的方式对静态成员函数进行访问
    //C2.getS();报错
    return 0;
}
/*
输出：
0x7ff7bfeff220
0x7ff7bfeff218
0x7ff7bfeff210
c1:8
c2:8
访问实例成员的非静态函数
静态成员函数
*/


/*
 
 静态变量存放在全局数据区，sizeof计算栈中分配的内存大小，所以sizeof不会计算类中静态数据成员的大小
 静态成员函数只能访问静态数据成员、静态成员函数和类以外的函数和数据，不能访问非静态数据成员，但静态成员函数或静态数据成员可由任意访问许可的函数访问。原因是：当前对象的地址（this）是被隐含地传递到被调用的函数的。但一个静态成员函数没有this指针，所以它无法访问非静态的成员函数。
 C++中类的成员函数默认都提供了this指针，在非静态成员函数中当你调用函数的时候，编译器都会“自动”帮你把这个this指针加到函数形参里去，类的成员函数都隐含了this指针
 类的静态函数被该类所有的实例所共享，因而没有this指针，不能访问类的非静态成员
 
 
 静态数据成员
 特点：
　　A、内存分配：在程序的全局数据区分配。
　　B、初始化和定义：
　　　 a、静态数据成员定义时要分配空间，所以不能在类声明中定义。
　　　 b、为了避免在多个使用该类的源文件中，对其重复定义，所在，不能在类的头文件中定义。
　　　 c、静态数据成员因为程序一开始运行就必需存在，所以其初始化的最佳位置在类的内部实现。
　　C、特点
　　　 a、对相于 public,protected,private 关键字的影响它和普通数据成员一样，
　　　 b、因为其空间在全局数据区分配，属于所有本类的对象共享，所以，它不属于特定的类对象，在没产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。
　　D、访问形式
　　　 a、 类对象名.静态数据成员名
   E、静态数据成员，主要用在类的所有实例都拥有的属性上。比如，对于一个存款类，帐号相对于每个实例都是不同的，但每个实例的利息是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局区的内存，所以节省存贮空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了，因为它们实际上是共用一个东西。

 //静态成员函数为什么不能访问本类中的非静态成员
 和静态数据成员一样，静态成员函数是类的一部分，而不是对象的一部分。如果要在类外调用公用的静态成员函数，要用类名和域运算符“∷”。如 Box∷volume( ); 实际上也允许通过对象名调用静态成员函数，如 a.volume( ); 但这并不意味着此函数是属于对象a的，而只是用a的类型而已。
 静态成员函数的作用是为了能处理静态数据成员。
 静态成员函数与非静态成员函数的根本区别是：非静态成员函数有this指针，静态成员函数并不属于某一对象，它与任何对象都无关，静态成员函数没有this指针。由此决定了静态成员函数不能访问本类中的非静态成员。
 在C++程序中，静态成员函数主要用来访问静态数据成员，而不访问非静态成员。假如在一个静态成员函数中有以下语句： cout<<height<<endl;
 //若height已声明为static，则引用本类中的静态成员，合法 cout<<width<<endl;
 //若width是非静态数据成员，不合法 但是，并不是绝对不能引用本类中的非静态成员，只是不能进行默认访问，因为无法知道应该去找哪个对象。如果一定要引用本类的非静态成员，应该加对象名和成员运算符“.”。如 cout<<a.width<<endl;
 //引用本类对象a中的非静态成员

 
 const:
 const修饰类的成员变量，表示该成员变量不能被修改。
 const修饰函数，表示本函数不会修改类内的数据成员。不会调用其他非const成员函数。
 const函数只能调用const函数，非const函数可以调用const函数，类外定义的const成员函数，在定义和声明出都需要const修饰符。
 
 static:
 1 对变量:
 a. 局部变量:
 在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。位于内存中静态存储区; 未初始化的局部动初始化为0. 作用域仍是局部作用域.
 注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。

 b. 全局变量.
 在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。静态存储区,未经初始化的全局静态变量会被程序自动初始化为0,全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。
 注: static修饰全局变量并未改变其存储位置及生命周期, 而是改变了其作用域,使得当前文件外的源文件无法访问该变量.不能被其他文件访问和修改,其他文件中可以使用相同名字的变量,不会产生冲突.

 2 对类:
 a. 成员变量
 用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static成员必须在类外进行初始化(初始化格式： int base::var=10;)，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化 。
 注意：
 不要试图在头文件中定义(初始化)静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上#ifndef #define #endif或者#pragma once也不行。
 静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。
 静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为 所属类类型的指针或引用。
 b. 成员函数
 注意：
 a. 用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。
 b. 静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。base::func(5,3);当static成员函数在类外定义时不-需要加static修饰符。
 c. 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。
 d. 不可以同时用const和static修饰成员函数。

 C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。

 我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。

 类的static变量在什么时候初始化，函数的static变量在什么时候初始化。
 类的静态成员在类实例化之前就存在了，并分配了内存。函数的static变量在执行此函数时进行实例化。
 
 静态数据成员在内存中只占一份空间，静态数据成员的值对所有的对象都是一样的。
 对于未含有静态成员的类，只有在定义对象时才分配成员空间，但包含静态数据成员的类，即使没有定义对象，也为静态数据成员分配了空间，它可以被引用。静态数据成员在程序编译时被分配空间，到程序结束时才释放空间。
 静态数据可以初始化，但只能在类体外进行初始化：一般形式为：数据类型 类名::静态数据成员名=初值；如 int Box::height = 30; 注意，不能使用参数初始化表对静态数据成员进行初始化，
 静态数据成员可以通过对象名引用，也可以通过类名引用

 
 //对象共享
 类中静态成员，所有对象共享，静态的东西是类下面所有的对象共有的。一个函数都是一块内存空间，但是不同的实例调用函数时却用的是私有的参数，一般传参时编译器会加上this来区分不同实例的调用，所以想要在不同对象之间来共享参数，那么就可以通过静态方法来实现，一般静态方法是不需要创建实例就可以直接调用的，而实例方法必须分配内存空间。
 
 
 #include <iostream>
 using namespace std;
 class Person
 {
 public:

     //静态成员变量 特点：
     //1 在编译阶段分配内存
     //2 类内声明，类外初始化
     //3 所有对象共享同一份数据
     static int m_A;   //静态成员变量
     int m_B;

     //静态成员函数 特点：
     //1 程序共享一个函数
     //2 静态成员函数只能访问静态成员变量
     static void func()   //静态成员函数
     {
         cout << "func调用" << endl;
         m_A = 100;    // 正确，因为 m_A 是静态成员变量
         //m_B = 100;  // 错误，m_B 不是静态成员变量，不可以访问
         cout << "m_A =" << m_A <<  endl;
     }
 private:

     //静态成员函数也可以控制访问权限
     static void func2()
     {
         cout << "func2调用" << endl;
     }
 };

 // 静态成员变量，类外初始化；
 // 由于所有对象共享静态成员变量 m_A，因此允许不创建对象来初始化静态成员变量  m_A
 // 直接 类名::m_A 初始化即可
 int Person::m_A = 10;
 
 int main()
 {
     //静态成员变量，有两种访问方式
 
     //1、通过创建一个对象来访问
     Person p1;
     p1.func();
 
     //2、通过 类名:: 直接访问
     Person::func();
     //Person::func2(); // func2 是私有权限的，无法访问
     return 0;
 }
 
 */
