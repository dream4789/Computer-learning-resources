#include <stdlib.h>
#include <iostream>
using namespace std;
class inner {
public:
    inner() { cout << "运行构造000" << endl; }
    ~inner() { cout << "运行析构111" << endl; }
};

int main(int argc, char *argv[])
{
    cout<<"new[]和delete[]结对使用"<<endl;
    inner *p = new inner();
    delete p;       //调用1次析构
    inner *pa = new inner[2];
    delete [] pa;    //调用2次析构
    
    //正常运行，因为new[]会创建一个数组，一个对象数组需要一定的空间大小，假设一个对象需要N字节大小，K个对象的数组就需要K*N个空间来构造对象数组，但是在delete[]时候，如何知道数组的长度呢？所以new[]会在K*N个空间的基础上，头部多申请4个字节，用于存储数组长度，这样delete[]时候才知道对象数组的大小，才会相应调用K次析构函数，并且释放K*N+4大小的内存。
    
    
    cout<<"new[]与delete结对使用"<<endl;
    //inner *p1 = new inner[2];      //整块内存的起始地址应该是A-4
    //delete p1;                     //释放起始地址为A的内存
    
    //程序挂掉了，并且，只调用了一次析构函数。我们使用了delete，delete不同于delete[]，它认为这只是一个对象占用的空间，不是对象数组，不会访问前4个字节获取长度，所以只调用了一次析构函数。而且，最后释放内存的时候只释放了起始地址为A的内存。然而这不是这一整块内存的起始地址，整块内存的起始地址应该是A-4，释放内存如果不从内存起始地址操作就会出现断错误，所以导致程序挂掉
    
    
    
    cout<<"new与delete[]结对使用"<<endl;
    //inner *p2 = new inner();      //整块内存的起始地址应该是A
    //delete [] p2;                  //释放起始地址为A-4的内存
    
    //程序挂掉了，并且，调用了不定次数的析构函数。是因为在new时候没有多申请4个字节存储长度，而delete[]时候还会向前找4个字节获取长度，这4个字节是未定义的，所以调用了不固定次数的析构函数，释放内存的时候也释放了起始地址为A-4的内存，而正常的起始地址应该是A。
    
    
    
    cout<<"new与delete不结对使用"<<endl;
    int *pint = new int(5);
    delete [] pint;
    
    int *pinta = new int[4];
    delete pinta;
    
    char *str = new char[5];
    delete str;
    cout << "运行成功！！！" << endl;
    
    /*
    char *str1 = new char[6];
    str1 = "hello";
    delete str1;
     */
    char *str2 = new char[6];
    cout<<"str2 = "<<sizeof(str2)<<endl;
    str2[0] = '\0';
        strcat(str2,"hello");
    delete [] str2;
    cout<<"str2 = "<<sizeof(str2)<<endl;
    //正常运行，int是内置类型，new[]和delete[]在配合int使用时知道int是内置类型，不需要析构函数，所以也就不需要多4个字节来存放数组长度，只需要直接操作内存即可
    
    
    char *need=new char[5];
    delete [] need;//需要delete删除，创建在堆上
    
    char *noneed="hello";//不需要delete，创建的空间是在栈上
    //new出来的空间是创建在堆上，是需要操作者本人进行清除的
    //char *p="hello"创建的空间是在栈上，是由系统自动清理
    
    return 0;
}

/*
new[]和delete[]结对使用
运行构造000
运行析构111
运行构造000
运行构造000
运行析构111
运行析构111
new[]与delete结对使用
new与delete[]结对使用
new与delete不结对使用
运行成功！！！
str2 = 8
str2 = 8
*/

/*
 当类型为int, float等内置类型时，new、delete、new[]、delete[]不需要配对使用；
 当是自定义类型时，new、delete和new[]、delete[]才需要配对使用。
 当然，我们平时编程过程中，为了保证代码的可读性，以及养成良好的编程习惯，最好确保所有情况都配对使用。

 一、new用法
 1.开辟单变量地址空间
    使用new运算符时必须已知数据类型，new运算符会向系统堆区申请足够的存储空间，如果申请成功，就返回该内存块的首地址，如果申请不成功，则返回零值。
     new运算符返回的是一个指向所分配类型变量（对象）的指针。对所创建的变量或对象，都是通过该指针来间接操作的，而动态创建的对象本身没有标识符名。

  一般使用格式：
         格式1：指针变量名=new 类型标识符；
         格式2：指针变量名=new 类型标识符（初始值）；
         格式3：指针变量名=new 类型标识符 [内存单元个数]；

 说明：格式1和格式2都是申请分配某一数据类型所占字节数的内存空间；但是格式2在内存分配成功后，同时将一初值存放到该内存单元中；而格式3可同时分配若干个内存单元，相当于形成一个动态数组。例如：

     1)new int;  //开辟一个存放整数的存储空间,返回一个指向该存储空间的地址。int *a = new int 即为将一个int类型的地址赋值给整型指针a
     2)int *a = new int(5) 作用同上,但是同时将整数空间赋值为5

 2.开辟数组空间

     对于数组进行动态分配的格式为：
        指针变量名=new 类型名[下标表达式];
        delete [ ] 指向该数组的指针变量名;
     两式中的方括号是非常重要的，两者必须配对使用，如果delete语句中少了方括号，因编译器认为该指针是指向数组第一个元素的指针，会产生回收不彻底的问题（只回收了第一个元素所占空间），加了方括号后就转化为指向数组的指针，回收整个数组。
     delete []的方括号中不需要填数组元素数，系统自知。即使写了，编译器也忽略。
     请注意“下标表达式”不必是常量表达式，即它的值不必在编译时确定，可以在运行时确定。
     一维: int *a = new int[100];    //开辟一个大小为100的整型数组空间
     二维: int **a = new int[5][6]
     三维及其以上:依此类推.
     一般用法: new 类型 （初值）

 二、delete用法

 1. 删除单变量地址空间
        int *a = new int;
        delete a;   //释放单个int的空间
 2. 删除数组空间
        int *a = new int[5];
        delete []a;    //释放int数组空间
 三、使用注意事项
 1. new 和delete都是内建的操作符，语言本身所固定了，无法重新定制，想要定制new和delete的行为，徒劳无功的行为。
 2. 动态分配失败，则返回一个空指针（NULL），表示发生了异常，堆资源不足，分配失败。
 3. 指针删除与堆空间释放。删除一个指针p（delete p;）实际意思是删除了p所指的目标（变量或对象等），释放了它所占的堆空间，而不是删除p本身（指针p本身并没有撤销，它自己仍然存在，该指针所占内存空间并未释放），释放堆空间后，ｐ成了空指针。
 4. 内存泄漏（memory leak）和重复释放。new与delete 是配对使用的， delete只能释放堆空间。如果new返回的指针值丢失，则所分配的堆空间无法回收，称内存泄漏，同一空间重复释放也是危险的，因为该空间可能已另分配，所以必须妥善保存new返回的指针，以保证不发生内存泄漏，也必须保证不会重复释放堆内存空间。
 5. 动态分配的变量或对象的生命期。我们也称堆空间为自由空间（free store），但必须记住释放该对象所占堆空间，并只能释放一次，在函数内建立，而在函数外释放，往往会出错。
 6. 要访问new所开辟的结构体空间,无法直接通过变量名进行,只能通过赋值的指针进行访问。
     用new和delete可以动态开辟和撤销地址空间。在编程序时,若用完一个变量(一般是暂时存储的数据),下次需要再用,但却又想省去重新初始化的功夫，可以在每次开始使用时开辟一个空间，在用完后撤销它。


 */


 /*

  delete和free，new和malloc

 当申请的空间是内置类型时：
    delete和free可以混用
 当申请的空间是自定义类型时：
    1>若没有析构函数，delete和malloc可以混用，有[]和没有[]都相同
    2>若申请的空间有析构函数时，malloc申请的空间可以用delete和free释放，但是用delete释放时不能加[]
    3>若申请的空间有析构函数时，new申请的空间不能用free释放，可以用delete释放，但是释放时必须加上[]
 
 
 对于基本类型而言，没有区别。
 根据需要new和malloc可以混用，new[]和malloc可以混用，delete、delete[]和free可以混用
 对于构造函数没有作用的类，new和malloc可以混用。
 对于构造函数有作用的类，如果想混用，需要显式调用构造函数的逻辑实现。
 对于没有显式定义析构函数的类，delete、delete[]和free可以混用。
 对于显式定义析构函数的类，delete[]和new[]必须配套使用，delete和free如果想混用，free需要显式调用析构函数。

 
 malloc只负责分配内存，free只负责释放内存。
 new在分配内存的同时，还会调用构造函数；delete在释放内存的同时还会调用析构函数。
 new[]在分配对应大小内存的同时，还会调用对应次数的构造函数；delete[]同理。
 
 delete只是c++的一个全局重载操作符。他只是在free前调用对象的析构方法
 但是new申请的内存用free释放则不会调用对象的析构方法

 int，float 这种数字类型过于简单，没有复杂的构造/析构函数，因此此时 new 和 malloc是等价的

*/