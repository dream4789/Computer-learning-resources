;一个学生的信息包括姓名、班级、学号、成绩，其中成绩需要精确到1位小数。实现以下功能：
;（1） 可以录入学生成绩（十进制形式）；
;（2） 可以按要求（如学号或成绩）进行排序显示；
;（3） 可以统计平均成绩；
;（4）可以统计不及格成绩、60-70、70-80、80-90、90-100各分数段的人数。

DATA SEGMENT
    NOTICE   DB 'Please input your choice:' ,0DH,0AH
             DB ' 1.Logging Data;'          ,0DH,0AH
             DB ' 2.Sort and Output;'       ,0DH,0AH
             DB ' 3.Get Average;'           ,0DH,0AH
             DB ' 4.Statistic of Ranges;'   ,0DH,0AH
             DB ' 5.Exit'                   ,0DH,0AH,'$'
             
    ERR		   DB 'ERROR!',0DH,0AH,'$'
    NOTICE1  DB 'Please input the NAME of the student:(ENTER for end)',0DH,0AH,'$'
    NOTICE2  DB 'Please input the CLASS of the student:'              ,0DH,0AH,'$'
    NOTICE3  DB 'Please input the ID of the student:'                 ,0DH,0AH,'$'
    NOTICE4  DB 'Please input the SCORE of the student:'              ,0DH,0AH,'$'
    NOTICE5  DB 'Do you want to log another one? Y/N'                 ,0DH,0AH,'$'
    NOTICE6  DB 'CHOOSE:'                 ,0DH,0AH
             DB ' 1. Sort by scores;'     ,0DH,0AH
             DB ' 2. Sort by IDs'         ,0DH,0AH,'$'
    
    NOTICE7  DB '0  ~  59:',0DH,0AH,'$'
    NOTICE8  DB '60 ~  69:',0DH,0AH,'$'
    NOTICE9  DB '70 ~  79:',0DH,0AH,'$'
    NOTICE10 DB '80 ~  89:',0DH,0AH,'$'
    NOTICE11 DB '90 ~ 100:',0DH,0AH,'$'
    TABLE	   DW CASE1, CASE2, CASE3, CASE4, CASE5, DEFAULT
    NUMBER 	 DW ?      ;The number of students
    
    COUNT0	 DW 0;不及格
    COUNT1	 DW 0;60~69
    COUNT2	 DW 0;70~79
    COUNT3	 DW 0;80~89
    COUNT4	 DW 0;90~100
    
    
    NAME_ARR	DB 100 DUP (10 DUP (?));All names are expected to shorter than 10 bytes
    NAME_BEGIN	EQU OFFSET NAME_ARR
    CLASS_ARR	DW 100 DUP (?)
    ID_ARR		DW 100 DUP (?)
    SCORE_ARR	DW 100 DUP (?)
    SORTED		DW 100 DUP (?)
    BUFFER		DB 10  DUP (0),'$'
    BUFREAR		EQU OFFSET BUFFER+10
    TYPE_NAME	DB 10
DATA ENDS

STACK SEGMENT STACK
	DB 100 DUP (?)
STACK ENDS

CODE SEGMENT
		ASSUME CS:CODE,DS:DATA,SS:STACK
START:	
		MOV AX, DATA
		MOV DS, AX
		MOV AH, 9
		MOV DX, OFFSET NOTICE
		INT 21H;Print NOTICE
		MOV AH, 1
		INT 21H;Get users choice in AL
		CALL CRLF
		SUB AL, '0'
		MOV BL, AL
		CMP BL, 5
		JBE CASE1TO5
		MOV BL, 6
CASE1TO5:
		DEC BL;from 0 to 5
		MOV BH, 0
		SHL BX, 1
		JMP TABLE[BX]
		

CASE1:
		CALL LOGDATA
		JMP START

CASE2:
		CALL SORT
		JMP START

CASE3:
		CALL GETAVERAGE
		JMP START

CASE4:
		CALL STATISTIC
		JMP START

CASE5:
		MOV AX, 4C00H
		INT 21H

DEFAULT:
		MOV AH, 9
		MOV DX, OFFSET ERR
		INT 21H
		;CALL DEBUG
		JMP START

LOGDATA PROC NEAR
		PUSH AX
		PUSH DX
LOG:
		MOV AH, 9
		MOV DX, OFFSET NOTICE1
		INT 21H
		CALL LOGNAME
		CALL CRLF
		MOV AH, 9
		MOV DX, OFFSET NOTICE2
		INT 21H
		CALL LOGCLASS
		CALL CRLF
		MOV AH, 9
		MOV DX, OFFSET NOTICE3
		INT 21H
		CALL LOGID
		CALL CRLF
		MOV AH, 9
		MOV DX, OFFSET NOTICE4
		INT 21H
		CALL LOGSCORE
		CALL CRLF
		INC NUMBER
CHOICE:
		MOV AH, 9
		MOV DX, OFFSET NOTICE5
		INT 21H
		MOV AH, 1
		INT 21H
		CALL CRLF
		CMP AL, 'Y'
		JE LOG
		CMP AL, 'y'
		JE LOG
		CMP AL, 'N'
		JE LOGEND
		CMP AL, 'n'
		JE LOGEND
		MOV AH, 9;Wrong input
		MOV DX, OFFSET ERR
		INT 21H
		JMP CHOICE
LOGEND:
		POP DX
		POP AX
		RET
LOGDATA ENDP

LOGNAME PROC NEAR
		PUSH AX
		PUSH BX
		PUSH DX
		PUSH SI
		MOV AX, NUMBER
		MOV CL, TYPE_NAME
		MUL CL
		MOV BX, AX
		XOR SI, SI
		LEA BX, NAME_ARR[BX]
		;MOV AH, 0AH
		;INT 21H;The start address of string is stored in DX
INLOOP0:
		MOV AH, 1
		INT 21H
		CMP AL, 0DH
		JE INLOOP0END
		MOV [BX+SI], AL
		INC SI
		JMP INLOOP0

INLOOP0END:
		MOV AL, '$'
		MOV [BX+SI], AL
		POP SI
		POP DX
		POP BX
		POP AX
		RET
LOGNAME ENDP

LOGCLASS PROC NEAR
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		PUSH SI
		MOV BX, 0
INLOOP:
		MOV AH, 8
		INT 21H
		XOR AH, AH
		CMP AL, 0DH
		JE INLOOPEND
		CMP AL, '0'
		JB INLOOP; abandon
		CMP AL, '9'
		JA INLOOP; abandon
		PUSH AX
		MOV AX, BX
		MOV CX, 10
		MUL CX
		MOV CX, AX; (CX) = (BX)*10
		POP AX
		JO INLOOP;overflow
		MOV DL, AL ;to show
		SUB AL, '0'
		ADD CX, AX
		JO INLOOP
		MOV BX, CX; (BX) = (BX)*10+(AX)
		MOV AH, 2
		INT 21H
		JMP INLOOP

INLOOPEND:
		MOV SI, NUMBER
		SHL SI, 1 
		MOV CLASS_ARR[SI], BX
		
		POP SI
		POP DX
		POP CX
		POP BX
		POP AX
		RET
LOGCLASS ENDP
LOGID PROC NEAR
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		PUSH SI
		MOV BX, 0
INLOOP1:
		MOV AH, 8
		INT 21H
		XOR AH, AH
		CMP AL, 0DH
		JE INLOOPEND1
		CMP AL, '0'
		JB INLOOP1; abandon
		CMP AL, '9'
		JA INLOOP1; abandon
		PUSH AX
		MOV AX, BX
		MOV CX, 10
		MUL CX
		MOV CX, AX; (CX) = (BX)*10
		POP AX
		JO INLOOP1;overflow
		MOV DL, AL ;to show
		SUB AL, '0'
		ADD CX, AX
		JO INLOOP1
		MOV BX, CX; (BX) = (BX)*10+(AX)
		MOV AH, 2
		INT 21H
		JMP INLOOP1

INLOOPEND1:
		MOV SI, NUMBER
		SHL SI, 1
		MOV ID_ARR[SI], BX
	
		POP SI
		POP DX
		POP CX
		POP BX
		POP AX
		RET
LOGID ENDP
LOGSCORE PROC NEAR
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		PUSH SI
		PUSH DI
		MOV BX, 0
		MOV SI, 0;a flag for '.'
		MOV DI, 100
INLOOP2:
		MOV AH, 8
		INT 21H
		XOR AH, AH
		CMP AL, 0DH
		JE INLOOPEND2
		CMP AL, '.'
		JE CHANGE
		CMP AL, '0'; integer part
		JB INLOOP2; abandon
		CMP AL, '9'
		JA INLOOP2; abandon
		PUSH AX
		MOV AX, BX
		MOV CX, 10
		MUL CX
		MOV CX, AX; (CX) = (BX)*10
		POP AX
		CMP CX, DI
		JA INLOOP2;overflow
		MOV DL, AL ;to show
		SUB AL, '0'
		ADD CX, AX
		CMP CX, DI
		JA INLOOP2
		MOV BX, CX; (BX) = (BX)*10+(AL)
		MOV AH, 2
		INT 21H
		JMP INLOOP2

CHANGE:
		CMP SI, 1
		JE INLOOP2
		MOV SI, 1
		MOV DI, 1000
		MOV DL, AL
		MOV AH, 2
		INT 21H
		JMP INLOOP2
MUL10:
		PUSH AX
		MOV AX, BX
		MOV CL, 10
		MUL CL
		MOV BX, AX; (BX) = (BX)*10
		MOV SI, 1
		POP AX
INLOOPEND2:
		CMP SI, 0
		JZ  MUL10
		MOV SI, NUMBER
		SHL SI, 1
		MOV SCORE_ARR[SI], BX
		
		POP DI
		POP SI
		POP DX
		POP CX
		POP BX
		POP AX
		RET

LOGSCORE ENDP
SORT PROC NEAR
		PUSH AX
		PUSH DX
		MOV AH, 9
		MOV DX, OFFSET NOTICE6
		INT 21H
		MOV AH, 1
		INT 21H
		CALL CRLF
		CMP AL, '2'
		JE SORT2
SORT1:
		CALL SORTSCORE
		JMP SHOW
SORT2:
		CALL SORTID
SHOW:
		CALL SHOWSORTED

		POP DX
		POP AX
		RET 
SORT ENDP
SORTSCORE PROC NEAR
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		PUSH SI
		PUSH DI
		MOV CX, NUMBER
		PUSH CX; protect CX
		LEA BX, SORTED
		XOR SI, SI
		XOR DX, DX
LOOP0:
		MOV [BX+SI], DX
		INC DX
		ADD SI, 2
		LOOP LOOP0

		POP CX
		DEC CX
		
LOOP1:
		MOV  DI, CX
		XOR SI, SI
		;LEA BX, SCORE_ARR
		;LEA SI, SORTED
		;CALL TAG
LOOP2:
		;CALL TAG
		;MOV DX, SI
		MOV BX, SORTED[SI]
		SHL BX, 1
		MOV AX, SCORE_ARR[BX]
		;CALL DECOUT
		;CALL CRLF
		;MOV SI, DX
		MOV BX, SORTED[SI+2]
		SHL BX, 1
		CMP AX, SCORE_ARR[BX]
		;MOV SI, DX
		JGE CONTI
		MOV DX, SORTED[SI]
		XCHG DX, SORTED[SI+2]
		MOV SORTED[SI], DX
CONTI:
		ADD SI, 2
		LOOP LOOP2
		MOV CX, DI
		LOOP LOOP1

;		MOV CX, NUMBER
;		MOV BX, OFFSET SORTED
;SORTEDLP:
;		CALL TAG
;		MOV AX, [BX]
;		CALL DECOUT
;		ADD BX, 2
;		LOOP SORTEDLP
;		CALL TAG

		POP DI
		POP SI
		POP DX
		POP CX
		POP BX
		POP AX
		RET

SORTSCORE ENDP
SORTID	PROC NEAR
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		PUSH SI
		PUSH DI
		MOV CX, NUMBER
		PUSH CX; protect CX
		LEA BX, SORTED
		XOR SI, SI
		XOR DX, DX
LP0:
		MOV [BX+SI], DX
		INC DX
		ADD SI,2
		LOOP LP0

		POP CX
		DEC CX
		
LP1:
		MOV  DI, CX
		LEA BX, ID_ARR
		LEA SI, SORTED
LP2:
		MOV AX, [BX]
		CMP AX, [BX+2]
		JLE CONTINUE
		MOV DX, [SI]
		XCHG DX, [SI+2]
		MOV [SI], DX
CONTINUE:
		ADD BX, 2
		ADD SI, 2
		LOOP LP2
		MOV CX, DI
		LOOP LP1

		POP DI
		POP SI
		POP DX
		POP CX
		POP BX
		POP AX
		RET
SORTID 	ENDP
SHOWSORTED PROC NEAR
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		PUSH SI

		LEA BX, SORTED
		MOV CX, NUMBER
		XOR SI, SI
SHOWLOOP:
		PUSH CX
;		CALL TAG
		MOV SI, [BX]
		PUSH SI 
		MOV AX, SI
		MOV CL, TYPE_NAME
		MUL CL
		MOV SI, AX
		LEA DX, NAME_ARR[SI]
		CALL NAMEOUT
		CALL SPACE
		POP SI
		SHL SI,1
		MOV AX, CLASS_ARR[SI]
		CALL DECOUT
		CALL SPACE
		MOV AX, ID_ARR[SI]
		CALL DECOUT
		CALL SPACE
		MOV AX, SCORE_ARR[SI]
		CALL SCOREOUT
		CALL SPACE

		CALL CRLF
		INC BX
		INC BX
		POP CX
		LOOP SHOWLOOP

		POP SI
		POP DX
		POP CX
		POP BX
		POP AX
		RET
SHOWSORTED ENDP
NAMEOUT PROC NEAR;first address is in DX
		PUSH AX

		MOV AH, 9
		INT 21H

		POP AX
		RET
NAMEOUT ENDP
DECOUT PROC NEAR
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		MOV BX, BUFREAR
		CMP AX, 0
		JZ ZERO
OUTLOOP:
		XOR AH, AH
		OR  AL, AL; number is in AX
		JZ	OUTLOOPFIN
		MOV CL, 10
		DIV CL;(AL)=(AX)/10,余数在AH
		ADD AH, '0'
		DEC BX
		MOV [BX], AH
		JMP OUTLOOP
ZERO:	
		MOV DL, '0'
		MOV AH, 2
		INT 21H
		POP DX
		POP CX
		POP BX
		POP AX
		RET

OUTLOOPFIN:
		MOV DX, BX
		MOV AH, 9
		INT 21H

		POP DX
		POP CX
		POP BX
		POP AX
		RET
DECOUT ENDP

SCOREOUT PROC NEAR
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		MOV BX, BUFREAR

		OR  AX, AX; number is in AX
		JZ	OUTLOOPFIN1
		MOV CL, 10
		DIV CL;(AL)=(AX)/10,余数在AH
		CMP AH, 0
		JZ OUTLOOP1;整数

		ADD AH, '0';一位小数
		DEC BX
		MOV [BX], AH
		MOV DL, '.'
		DEC BX
		MOV [BX], DL
		
OUTLOOP1:
		XOR AH, AH
		OR  AL, AL; number is in AX
		JZ	OUTLOOPFIN1
		MOV CL, 10
		DIV CL;(AL)=(AX)/10,余数在AH
		ADD AH, '0'
		DEC BX
		MOV [BX], AH
		JMP OUTLOOP1

OUTLOOPFIN1:
		
		MOV DX, BX
		MOV AH, 9
		INT 21H	

		POP DX
		POP CX
		POP BX
		POP AX
		RET
SCOREOUT ENDP

GETAVERAGE PROC NEAR
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH SI
		XOR AX, AX
		MOV CX, NUMBER
		OR CX, CX
		JZ ACCEND
		LEA BX, SCORE_ARR
		XOR SI, SI
		PUSH CX
ACCUMULATE:
		ADD AX, [BX+SI]
		INC SI
		INC SI	
		LOOP ACCUMULATE

		POP CX
		OR CX, CX 
		DIV CX

		PUSH AX
		MOV AX, DX
		MOV DX, 10	
		MUL DX	
		DIV CX	
		CMP AX, 5;四舍五入
		JB ACCEND	
		POP AX
		INC AX
		JMP NEXT1
		
		

ACCEND:		
		POP AX
NEXT1:
		CALL SCOREOUT
		CALL CRLF
		POP SI
		POP CX
		POP BX
		POP AX
		RET
GETAVERAGE ENDP


STATISTIC PROC NEAR
		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		PUSH SI
		LEA BX, SCORE_ARR
		XOR SI, SI
		MOV CX, NUMBER
		XOR AX, AX
STATISLOOP:
		MOV AX, [BX+SI]
		CMP AX, 600
		JB  ADDCOUNT0
		CMP AX, 700
		JB  ADDCOUNT1
		CMP AX, 800
		JB  ADDCOUNT2
		CMP AX, 900
		JB  ADDCOUNT3
		INC COUNT4
		JMP NEXT
ADDCOUNT0:
		INC COUNT0
		JMP NEXT 
ADDCOUNT1:
		INC COUNT1
		JMP NEXT
ADDCOUNT2:
		INC COUNT2
		JMP NEXT
ADDCOUNT3:
		INC COUNT3
NEXT:
		INC SI
		INC SI
		LOOP STATISLOOP

		MOV DX, OFFSET NOTICE7
		MOV AH, 9
		INT 21H
		MOV AX, WORD PTR COUNT0
		CALL DECOUT 
		CALL CRLF
		MOV DX, OFFSET NOTICE8
		MOV AH, 9
		INT 21H
		MOV AX, WORD PTR COUNT1
		CALL DECOUT 
		CALL CRLF
		MOV DX, OFFSET NOTICE9
		MOV AH, 9
		INT 21H
		MOV AX, WORD PTR COUNT2
		CALL DECOUT 
		CALL CRLF
		MOV DX, OFFSET NOTICE10
		MOV AH, 9
		INT 21H
		MOV AX, WORD PTR COUNT3
		CALL DECOUT 
		CALL CRLF
		MOV DX, OFFSET NOTICE11
		MOV AH, 9
		INT 21H
		MOV AX, WORD PTR COUNT4
		CALL DECOUT 
		CALL CRLF
		POP SI
		POP DX
		POP CX
		POP BX
		POP AX
		RET
STATISTIC ENDP
CRLF PROC NEAR
	PUSH AX
	PUSH DX
	MOV DL, 0DH
	MOV AH, 2
	INT 21H
	MOV DL, 0AH
	MOV AH, 2
	INT 21H
	POP DX
	POP AX
	RET
CRLF ENDP
SPACE PROC NEAR
	PUSH AX
	PUSH DX
	MOV DL, ' '
	MOV AH, 2
	INT 21H
	POP DX
	POP AX
	RET
SPACE ENDP
DEBUG PROC NEAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	PUSH SI
	MOV CX, NUMBER
	MOV BX, NAME_BEGIN
	XOR SI, SI
NAMELP:
	ADD BX, SI
	MOV DX, BX
	MOV AH, 9
	INT 21H
	CALL SPACE
	ADD SI, WORD PTR  TYPE_NAME
	LOOP NAMELP

	MOV CX, NUMBER
	XOR SI, SI
CLASSLP:
	MOV AX, CLASS_ARR[SI]
	CALL DECOUT
	ADD SI, 2
	LOOP CLASSLP

	MOV CX, NUMBER
	XOR SI, SI
IDLP:
	MOV AX, ID_ARR[SI]
	CALL DECOUT
	ADD SI, 2
	LOOP IDLP

	MOV CX, NUMBER
	XOR SI, SI
SCORELP:
	MOV AX, SCORE_ARR[SI]
	CALL SCOREOUT
	ADD SI, 2
	LOOP SCORELP

	POP SI
	POP DX
	POP CX
	POP BX
	POP AX
	RET
DEBUG ENDP
TAG PROC NEAR
	PUSH AX
	PUSH DX

	MOV DL, '!'
	MOV AH, 2
	INT 21H
	

	POP DX
	POP AX
	RET
TAG ENDP
CODE ENDS
	 END START