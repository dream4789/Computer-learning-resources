<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<li>原生提供 Proxy</li>
		<li>var proxy = new Proxy(target, handler);</li>
		<script>
			var proxy = new Proxy({}, {
				get: function(target, propKey) {
					return 35;
				}
			});

			console.log(proxy.time); // 35
			console.log(proxy.name); // 35
			console.log(proxy.title); // 35
		</script>
		<li>handler 没有设置任何拦截，那就等同于直接通向原对象</li>
		<script>
			var target = {};
			var handler = {};
			var proxy1 = new Proxy(target, handler);
			proxy1.a = 'b';
			console.log(target.a); // "b"
		</script>
		<li>同一个拦截器函数，可以设置拦截多个操作</li>
		<script>
			var handler = {
				get: function(target, name) {
					if (name === 'prototype') {
						return Object.prototype;
					}
					return 'Hello, ' + name;
				},

				apply: function(target, thisBinding, args) {
					return args[0];
				},

				construct: function(target, args) {
					return {
						value: args[1]
					};
				}
			};

			var fproxy = new Proxy(function(x, y) {
				return x + y;
			}, handler);

			console.log(fproxy(1, 2)); // 1
			console.log(new fproxy(1, 2)); // {value: 2}
			console.log(fproxy.prototype === Object.prototype); // true
			console.log(fproxy.foo === "Hello, foo"); // true
		</script>
		<li>get</li>
		<script>
			var person = {
				name: "张三"
			};

			var proxy2 = new Proxy(person, {
				get: function(target, propKey) {
					if (propKey in target) {
						return target[propKey];
					} else {
						throw new ReferenceError("Prop name \"" + propKey + "\" does not exist.");
					}
				}
			});

			console.log(proxy2.name); // "张三"
			console.log(proxy2.age); // 抛出一个错误
		</script>
		<li>get方法可以继承</li>
		拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。<br>
		<script>
			var person1 = {
				foo: "张三11"
			};
			let proto = new Proxy(person1, {
				get(target, propertyKey, receiver) {
					// console.log(receiver);
					console.log('GET ' + propertyKey);
					return target[propertyKey];
				}
			});

			let obj1 = Object.create(proto);
			console.log(obj1.foo); // "GET foo"  张三11
		</script>




		<script>
			// 对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为
			var obj = new Proxy({}, {
				get: function(target, propKey, receiver) {
					console.log(`getting ${propKey}!`);
					return Reflect.get(target, propKey, receiver);
				},
				set: function(target, propKey, value, receiver) {
					console.log(`setting ${propKey}!`);
					return Reflect.set(target, propKey, value, receiver);
				}
			});
			// 对设置了拦截行为的对象obj，去读写它的属性
			obj.count = 1
			//  setting count!
			++obj.count
			//  getting count!
			//  setting count!
		</script>
	</body>
</html>
