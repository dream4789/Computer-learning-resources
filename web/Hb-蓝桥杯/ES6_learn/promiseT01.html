<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<li>回调</li>
		<script>
			let p1 = new Promise((resolve, reject) => {
				resolve('成功') // 执行，fulfilled
				reject('失败') // 忽略
			})
			console.log('p1', p1)

			let p2 = new Promise((resolve, reject) => {
				reject('失败') // 执行，rejected
				resolve('成功') // 忽略
			});
			console.log('p2', p2);

			let p3 = new Promise((resolve, reject) => {
				throw ('报错') // 执行，rejected
			});
			console.log('p3', p3);

			console.log('----------------');
		</script>
		<hr>
		<li>Promise 新建后就会立即执行</li>
		<li>首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</li>
		<br>
		<li>Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数</li>
		<br>
		<li>同步语句，先执行</li>
		<li>resolved 状态和 rejected在任务循环结束后（同步任务结束后）再运行</li>
		<script>
			console.log('=================');
			// Promise 新建后就会立即执行
			let promise = new Promise(function(resolve, reject) {
				console.log('Promise');
				resolve();
			});
			// Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数
			promise.then(function() {
				console.log('resolved.');
			});

			console.log('Hi!'); // 同步语句，先执行
			console.log('----------------'); // 同步语句，先执行
		</script>
		<script>
			console.log('=================');
			new Promise((resolve, reject) => {
				resolve(1); // 最后执行
				reject(3); // 无效
				console.log('T:', 2); // 1同步语句
			}).then(r => { // 接收resolve
				console.log('res:', r);
			}).catch(r => { // 接收reject
				console.log('rej/cat:', r);
			});
			console.log('T11-----------'); // 2同步语句
		</script>
		<script>
			console.log('=================');
			new Promise((resolve, reject) => {
				reject(1); // 最后执行
				resolve(3); // 无效
				console.log('T:', 2); // 1同步语句
			}).then(r => { // 接收resolve
				console.log('res:', r);
			}).catch(r => { // 接收reject
				console.log('rej/cat:', r);
			})
			console.log('T22-----------'); // 2同步语句
		</script>
		<hr>
		<li>timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。</li>
		<li>过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。</li>
		<script>
			console.log('=================');

			function timeout(ms) {
				return new Promise((resolve, reject) => {
					setTimeout(resolve, ms, 'done');
				});
			}
			timeout(1000).then((value) => {
				console.log(value);
			});
			console.log('----------------');
		</script>
		<hr>
		<script>
			console.log('111==================111')
			setTimeout(function() {
				console.log('three'); // 
			}, 10);

			Promise.resolve().then(function() {
				console.log('two');
			});

			console.log('one'); // 同步事件
		</script>
		<hr>
		<script>
			const p = Promise.resolve('出错了1');
			// 等同于
			// const p = new Promise((resolve, reject) => resolve('出错了'))
			p.then(function(s) {
				console.log('1:', s) // 出错了
			});
			p.then(function(s) {
				console.log('2:', s) // 出错了
			}, null);

			p.then(null, function(s) {
				console.log('3:', s)
			});
			p.catch(function(s) {
				console.log('4:'.s)
			});


			const pp = Promise.reject('出错了2');
			// 等同于
			// const p = new Promise((resolve, reject) => reject('出错了'))
			pp.then(function(s) {
				console.log('1:', s)
			}).catch(function(s) {
				console.log('11:', s) // 出错了
			});
			pp.then(function(s) {
				console.log('2:', s)
			}, null).catch(function(s) {
				console.log('22:', s) // 出错了
			});

			pp.then(null, function(s) {
				console.log('3:', s) // 出错了
			});
			pp.catch(function(s) {
				console.log('4:'.s)
			});
		</script>
		<hr>
		<script>
			function sleep(delay) {
				var start = (new Date()).getTime();
				while ((new Date()).getTime() - start < delay) {
					continue;
				}
			}

			// function test() {
			//   console.log('111');
			//   sleep(2000);
			//   console.log('222');
			// }
			// test()

			setTimeout(() => {
				console.log('延时10s了')
			}, 3000) // 放入回调队列，同时开始计时

			sleep(10000);
			// 延时10s执行
		</script>

	</body>
</html>
