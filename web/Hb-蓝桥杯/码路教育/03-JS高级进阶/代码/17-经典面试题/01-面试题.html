<!-- <script>
    // let a = {
    //     i:0,
    //     valueOf:function(){
    //         return ++this.i
    //     }
    // }; 

    let a = {
        i: 0,
        toString: function () {
            return ++this.i
        }
    };
    if (a == 1 && a == 2 && a == 3) {
        console.log("i love you~");
    }
</script> -->

<!-- <script>
    let a = [1,2,3];
    a.toString = a.shift;
    if (a == 1 && a == 2 && a == 3) {
        console.log("i love you~");
    }
</script> -->

<!-- <script>
    // Object.defineProperty()

    let obj = {};
    obj.name = "wc";
    obj.age = 18;

    // Object.defineProperty()
    // 参数一：给哪个对象添加属性
    // 参数二：添加什么属性
    // 参数三：是一个对象  精细化设置属性
    Object.defineProperty(obj,"address",{
        value:"bj"
    })
</script> -->

<!-- <script>
    let obj = {};
    obj.name = "wc";
    obj.age = 18;

    Object.defineProperty(obj, "address", {
        // get叫访问器
        // 当你访问address时，会走访问器
        get(){
            return "ok"
        }
    })
</script> -->

<!-- <script>
    let i=0;
    Object.defineProperty(window,"a",{
        get(){
            return ++i;
        }
    })
    if (a == 1 && a == 2 && a == 3) {
        console.log("i love you~");
    }
</script> -->

<!-- ======================================= -->

<!-- <script>
    let arr = ["a", "b", "c"];
    console.log(arr);
    setTimeout(() => {
        arr.push("d");
        console.log(arr);
    }, 1000)
</script> -->

<!-- <script>
    Array.prototype.mypush = function (val) {
        this[this.length] = val;
        this.length++;
        return this.length;
    }
    let arr = ["a", "b", "c"];
    // console.log(arr);
    setTimeout(() => {
        console.log(arr.mypush("d"));
        console.log(arr);
    }, 3000);
</script> -->

<!-- <script>
    let obj = {
        2: 3,
        3: 4,
        length: 2,
        push: Array.prototype.push
    }
    // console.log(obj[2]);
    obj.push(1); // obj[2] = 1   obj.length++ 
    obj.push(2);  // obj[3] = 2   obj.length++
    console.log(obj);  // {2:1,3:2,length:4,push:f}
</script> -->

<!-- <script>
    let arr = ["a","b"];
    console.log(arr);
    // push：把c放到数组中，并让length++
    arr.push("c")
    console.log(arr);
</script> -->

<!-- <script>
    let obj = {
        2: 3,
        3: 4,
        length: 2,
        // push是数组的push   
        push: Array.prototype.push
    }

    obj.push(1); // obj[2] = 1; length++
    obj.push(2); // obj[3] = 2; length++
    console.log(obj);
</script> -->

<!-- <script>
    function Dog(name) {
        this.name = name;

        // 在构造器中，返回一个null，和没有写是一样的
        // return null;

        // 在构造器，返回一个基本数据类型，和没有写是一样的
        // return 123

        // 在构造器中，返回一个对象，那么最终new出来的是自己写的对象
        // return {age:100}

        // 在构造器中，返回一个函数，那么最终new出来的是一个函数
        // return function(){
        //     console.log("fn....");
        // }
    }

    let wc = new Dog("wangcai");
    console.log(wc);
</script> -->

<!-- <script>
    function Dog(name) {
        this.name = name;

        // return {
        //     age:110
        // }

        return function(){
            console.log("fn...");
        }
    }
    Dog.prototype.bark = function () {
        console.log('wangwang');
    }
    Dog.prototype.sayName = function () {
        console.log('my name is ' + this.name);
    }
    /*
    let wc = new Dog('旺财');
    wc.sayName();
    wc.bark();
    */

    // ===================== 第1版
    // Constuctor,
    // function _new(Ctor, ...args) {
    //     let obj = {};
    //     obj.__proto__ = Ctor.prototype;
    //     Ctor.apply(obj, args)
    //     return obj;
    // }

    // ==================== 第2版
    function _new(Ctor, ...args) {
        if (!Ctor.hasOwnProperty("prototype")) {
            // return "请传递一个构造器"
            throw new TypeError(`Ctor is not a constructor`)
        }
        let obj = Object.create(Ctor.prototype)
        let result = Ctor.apply(obj, args);

        if(result !== null && (typeof result == "object" || typeof result == "function")){
            return result;
        }

        return obj;
    }

    // let wc = _new("hello", '旺财');
    // console.log(wc);
    // let wc = _new(123, '旺财');
    let wc = _new(Dog, '旺财');
    console.log(wc);
    // wc.bark(); //=>"wangwang"

    // wc.sayName(); //=>"my name is 旺财"
    // console.log(wc instanceof Dog); //=>true
</script> -->

<!-- <script>
    function Pig(name) {
        this.name = name;
        return function(){
            console.log("xxx");
        }
    }
    function _new2(Ctor,...args){
        let obj = {};
        obj.__proto__ = Ctor.prototype;
        Ctor.apply(obj,args)
        return obj;
    }
    function _new(Ctor, ...args) {
        if (!Ctor.hasOwnProperty("prototype")) {
            throw new TypeError("Ctor is not a constructor")
        }
        let obj = Object.create(Ctor.prototype);
        let result = Ctor.apply(obj,args);
        if(result !== null && (typeof result == "object" || typeof result == "function")){
            return result;
        }
        return obj;
    }
    // let p = new Pig("peiqi");
    let p = _new(Pig,"peiqi")
    // let p = _new("ok", "peiqi")
    console.log(p);
</script> -->

<!-- <script>
    // 手写call

    ;(function(){
        function mycall(){

        }
        // 挂载到Function的原型对象上
        // 就意味着所有的函数都可以调用mycall
        Function.prototype.mycall = mycall;
    })()

    function fn(num1,num2){
        console.log(this);
        return num1+num2;
    }
    let obj = {name:"wc"};
    // let res = fn.call(obj,1,2);
    let res = fn.mycall(obj,1,2);
    console.log(res);
</script> -->


<!-- <script>
    ; (function () {
        // 接收实参有三种方案:
        //    1)通过形参
        //    2)通过...args
        //    3)通过arguments  伪数组  接收了所有的实以
        function mycall(context) {
            // console.log(arguments);
            console.log(Array.isArray(arguments));
        }
        Function.prototype.mycall = mycall;
    })()

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" };
    let res = fn.mycall(obj, 1, 2);
    console.log(res);
</script> -->


<!-- <script>
    ; (function () {
        function mycall(context) {

            let args = [];  // 收集函数调用时的参数
            for(let i=1; i<arguments.length; i++){
                args.push(arguments[i])
            }
            console.log(args);
        }
        Function.prototype.mycall = mycall;
    })()

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" };
    let res = fn.mycall(obj, 1, 2);
    console.log(res);
</script> -->


<!-- <script>
    ; (function () {
        function mycall(context) {
            context = context ? Object(context) : window

            let args = [];  
            for (let i = 1; i < arguments.length; i++) {
                args.push(arguments[i])
            }
            console.log(args);
        }
        Function.prototype.mycall = mycall;
    })()

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" };
    let res = fn.mycall();
    // let res = fn.call("hello", 1, 2);
    // let res = fn.mycall(obj, 1, 2);
    console.log(res);
</script> -->

<!-- <script>
    ; (function () {
        function mycall(context) {
            context = context ? Object(context) : window
            // this表示  谁调用mycall，this就是谁  fn
            // this ===> fn  this();
            console.log("---");
            // this();  // 独立函数调用  fn中的this表示window  不OK
            console.log("---");
            let args = [];
            for (let i = 1; i < arguments.length; i++) {
                args.push(arguments[i])
            }
        }
        Function.prototype.mycall = mycall;
    })()

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" };
    let res = fn.mycall();
    // let res = fn.call("hello", 1, 2);
    // let res = fn.mycall(obj, 1, 2);
    console.log(res);
</script> -->

<!-- <script>
    ; (function () {
        function mycall(context) {
            context = context ? Object(context) : window
            context.f = this; // f也是指向fn函数
            let args = [];
            for (let i = 1; i < arguments.length; i++) {
                args.push(arguments[i])
            }
            let res = context.f(...args);  // 隐式绑定
            delete context.f;
            return res;
        }
        Function.prototype.mycall = mycall;
    })()

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" };
    let res = fn.mycall(obj, 1, 2);
    // let res = fn.call("hello", 1, 2);
    // let res = fn.mycall(obj, 1, 2);
    console.log(res);
</script> -->

<!-- <script>
    ; (function () {
        function mlapply(context,args) {
            context = context ? Object(context) : window;
            // this是fn  隐式绑定
            // this();  fn中的this是window
            context.f = this;
            let res = context.f(...args);
            delete context.f;
            return res;
        }
        Function.prototype.mlapply = mlapply;
    }())

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" }
    // 1）改变fn中的this指向   2）让fn执行
    let res = fn.mlapply(obj, [1, 2]);
    console.log(res);
</script> -->

<!-- <script>
    ; (function () {  // 讨论3分钟 
        function mlapply(context, args) {
            context = context ? Object(context) : window;
            context.f = this;
            let res = context.f(...args);
            delete context.f;
            return res;
        }
        Function.prototype.mlapply = mlapply;
    }())

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" }
    let res = fn.mlapply(obj, [1, 2]);
    console.log(res);
</script> -->

<!-- <script>

    function fn(num1,num2){
        console.log(this);
        return num1+num2;
    }
    // console.log(fn(1, 2));;  // 独立函数调用  函数中的this表示window

    // 显示绑定：call  apply   bind
    // 手写call的原理  手写apply的原理
    // 为什么要写？答：学习JS高级， 面试

    let obj = {name:"wc"}
    console.log(fn.apply(obj, [100, 200]));
</script> -->

<!-- <script>
    // 使用原生JS，去模拟apply的实现
    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    // 这样写，只能让fn调用mlapply
    // fn.mlapply = function(){
    //     console.log("mlapplly");
    // }
    let obj = { name: "wc" }
    console.log(fn.mlapply(obj, [100, 200]));
</script> -->

<!-- <script>
    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    Function.prototype.mlapply = function (context, args) {
        // this 表示 fn
        // this();  // 独立函数调用
        context.xxx = this;
        // 让fn中的this指向context
        return context.xxx(...args);
    }
    let obj = { name: "wc" }
    console.log(fn.mlapply(obj, [100, 200]));
</script> -->

<!-- <script>
    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    Function.prototype.mlapply = function (context, args) {
        context = context ? Object(context) : window;
        context.xxx = this;
        if (!args) {
            // 没有传递参数
            return context.xxx()
        }
        let res = context.xxx(...args);
        delete context.xxx;
        return res;
    }
    let obj = { name: "wc" }
    console.log(fn.mlapply(obj));
</script> -->

<!-- <script>
    // 封装检测数据类型的方法

    // 利用typeof检测基本类型和函数，非常准确
    console.log(typeof 123);  // number
    console.log(typeof NaN);  // number
    console.log(typeof "hello");  // string
    console.log(typeof true);  // boolean
    console.log(typeof undefined);  // undefined
    console.log(typeof function () { });  // function

    // 检测其它的，结果都是object
    console.log(typeof null);  // object
    console.log(typeof {});  // object
    console.log(typeof []);   // object
</script> -->

<!-- <script>
    // instanceof 用来检测某个对象是否属于某个类的实例
    // 123不是对象
    console.log(123 instanceof Number);  // false
    let num = new Number(123)
    console.log(num instanceof Number);  // true

    console.log({} instanceof Object);  // true
    console.log([] instanceof Array);  // true
    console.log(function(){} instanceof Function);  // true

    console.log(function(){} instanceof Object);  // true
    console.log([] instanceof Object);  // true

    // console.log(123 instanceof string);

    // instanceof 的不足：
    //   1）可以检测引用数据类型，不能检测基本数据
    //   2）所有的引用数据类型，都是Object的实例
    //   3）可以人为修改原型链，导致检测的结果不准备
</script> -->

<!-- <script>
    let n  = new Number(110);
    // 人为可以修改constructor指向 
    n.constructor = Array;
    console.log(n.constructor  === Number);  // true
    // console.log({}.constructor  === Number);  // false
    // console.log({}.constructor  === Object);  // true
    // console.log([].constructor  === Array);  // true

    // console.log(123.constructor  === Number);  // 不行

    // 不足：
    //   1）可以检测引用数据类型，不能检测基本数据类型
    //   2）人为可以修改constructor指向 ，检测的结果就不准备
</script> -->

<!-- <script>
    console.log(Object.prototype.toString.call(123)); // [object Number]
    console.log(Object.prototype.toString.call("ok")); // [object String]
    console.log(Object.prototype.toString.call(true)); // [object Boolean]
    console.log(Object.prototype.toString.call([])); // [object Array]
    console.log(Object.prototype.toString.call({})); // [object Object]
    console.log(Object.prototype.toString.call(function () { })); // [object Function]
    function Person() { }; let p = new Person();
    console.log(Object.prototype.toString.call(p)); // [object Object]
    console.log(Object.prototype.toString.call(/abc/)); // [object RegExp]
    console.log(Object.prototype.toString.call(null)); // [object Null]
    console.log(Object.prototype.toString.call(undefined)); // [object Undefined]
    let d = new Date();
    console.log(Object.prototype.toString.call(d)); // [object Date]
    let s = Symbol();
    console.log(Object.prototype.toString.call(s)); // [object Symbol]
</script> -->

<!-- <script>
    // function checkType(data) {
    //     // let type = Object.prototype.toString.call(data)

    //     // return type.slice(8, -1);

    //     // return type.substring(8,type.length-1).toLowerCase();

    //     return Object.prototype.toString.call(data).slice(8, -1).toLowerCase();
    // }

    let checkType = data => Object.prototype.toString.call(data).slice(8, -1).toLowerCase();

    // let type = checkType("hello");
    // let type = checkType(123);
    let type = checkType([]);
    console.log(type); // string  number  array
</script> -->

<!-- <script>
    let checkType = data => Object.prototype.toString.call(data).slice(8, -1).toLowerCase();
    let type = checkType("hello");
    console.log(type); 
</script> -->

<!-- <script>
    // let a = {
    //     i:0,
    //     valueOf:function(){
    //         return ++this.i
    //     }
    // }; 

    let a = {
        i: 0,
        toString: function () {
            return ++this.i
        }
    };
    if (a == 1 && a == 2 && a == 3) {
        console.log("i love you~");
    }
</script> -->

<!-- <script>
    let a = [1,2,3];
    a.toString = a.shift;
    if (a == 1 && a == 2 && a == 3) {
        console.log("i love you~");
    }
</script> -->

<!-- <script>
    // Object.defineProperty()

    let obj = {};
    obj.name = "wc";
    obj.age = 18;

    // Object.defineProperty()
    // 参数一：给哪个对象添加属性
    // 参数二：添加什么属性
    // 参数三：是一个对象  精细化设置属性
    Object.defineProperty(obj,"address",{
        value:"bj"
    })
</script> -->

<!-- <script>
    let obj = {};
    obj.name = "wc";
    obj.age = 18;

    Object.defineProperty(obj, "address", {
        // get叫访问器
        // 当你访问address时，会走访问器
        get(){
            return "ok"
        }
    })
</script> -->

<!-- <script>
    let i=0;
    Object.defineProperty(window,"a",{
        get(){
            return ++i;
        }
    })
    if (a == 1 && a == 2 && a == 3) {
        console.log("i love you~");
    }
</script> -->

<!-- ======================================= -->

<!-- <script>
    let arr = ["a", "b", "c"];
    console.log(arr);
    setTimeout(() => {
        arr.push("d");
        console.log(arr);
    }, 1000)
</script> -->

<!-- <script>
    Array.prototype.mypush = function (val) {
        this[this.length] = val;
        this.length++;
        return this.length;
    }
    let arr = ["a", "b", "c"];
    // console.log(arr);
    setTimeout(() => {
        console.log(arr.mypush("d"));
        console.log(arr);
    }, 3000);
</script> -->

<!-- <script>
    let obj = {
        2: 3,
        3: 4,
        length: 2,
        push: Array.prototype.push
    }
    // console.log(obj[2]);
    obj.push(1); // obj[2] = 1   obj.length++ 
    obj.push(2);  // obj[3] = 2   obj.length++
    console.log(obj);  // {2:1,3:2,length:4,push:f}
</script> -->

<!-- <script>
    let arr = ["a","b"];
    console.log(arr);
    // push：把c放到数组中，并让length++
    arr.push("c")
    console.log(arr);
</script> -->

<!-- <script>
    let obj = {
        2: 3,
        3: 4,
        length: 2,
        // push是数组的push   
        push: Array.prototype.push
    }

    obj.push(1); // obj[2] = 1; length++
    obj.push(2); // obj[3] = 2; length++
    console.log(obj);
</script> -->

<!-- <script>
    function Dog(name) {
        this.name = name;

        // 在构造器中，返回一个null，和没有写是一样的
        // return null;

        // 在构造器，返回一个基本数据类型，和没有写是一样的
        // return 123

        // 在构造器中，返回一个对象，那么最终new出来的是自己写的对象
        // return {age:100}

        // 在构造器中，返回一个函数，那么最终new出来的是一个函数
        // return function(){
        //     console.log("fn....");
        // }
    }

    let wc = new Dog("wangcai");
    console.log(wc);
</script> -->

<!-- <script>
    function Dog(name) {
        this.name = name;

        // return {
        //     age:110
        // }

        return function(){
            console.log("fn...");
        }
    }
    Dog.prototype.bark = function () {
        console.log('wangwang');
    }
    Dog.prototype.sayName = function () {
        console.log('my name is ' + this.name);
    }
    /*
    let wc = new Dog('旺财');
    wc.sayName();
    wc.bark();
    */

    // ===================== 第1版
    // Constuctor,
    // function _new(Ctor, ...args) {
    //     let obj = {};
    //     obj.__proto__ = Ctor.prototype;
    //     Ctor.apply(obj, args)
    //     return obj;
    // }

    // ==================== 第2版
    function _new(Ctor, ...args) {
        if (!Ctor.hasOwnProperty("prototype")) {
            // return "请传递一个构造器"
            throw new TypeError(`Ctor is not a constructor`)
        }
        let obj = Object.create(Ctor.prototype)
        let result = Ctor.apply(obj, args);

        if(result !== null && (typeof result == "object" || typeof result == "function")){
            return result;
        }

        return obj;
    }

    // let wc = _new("hello", '旺财');
    // console.log(wc);
    // let wc = _new(123, '旺财');
    let wc = _new(Dog, '旺财');
    console.log(wc);
    // wc.bark(); //=>"wangwang"

    // wc.sayName(); //=>"my name is 旺财"
    // console.log(wc instanceof Dog); //=>true
</script> -->

<!-- <script>
    function Pig(name) {
        this.name = name;
        return function(){
            console.log("xxx");
        }
    }
    function _new2(Ctor,...args){
        let obj = {};
        obj.__proto__ = Ctor.prototype;
        Ctor.apply(obj,args)
        return obj;
    }
    function _new(Ctor, ...args) {
        if (!Ctor.hasOwnProperty("prototype")) {
            throw new TypeError("Ctor is not a constructor")
        }
        let obj = Object.create(Ctor.prototype);
        let result = Ctor.apply(obj,args);
        if(result !== null && (typeof result == "object" || typeof result == "function")){
            return result;
        }
        return obj;
    }
    // let p = new Pig("peiqi");
    let p = _new(Pig,"peiqi")
    // let p = _new("ok", "peiqi")
    console.log(p);
</script> -->

<!-- <script>
    // 手写call

    ;(function(){
        function mycall(){

        }
        // 挂载到Function的原型对象上
        // 就意味着所有的函数都可以调用mycall
        Function.prototype.mycall = mycall;
    })()

    function fn(num1,num2){
        console.log(this);
        return num1+num2;
    }
    let obj = {name:"wc"};
    // let res = fn.call(obj,1,2);
    let res = fn.mycall(obj,1,2);
    console.log(res);
</script> -->


<!-- <script>
    ; (function () {
        // 接收实参有三种方案:
        //    1)通过形参
        //    2)通过...args
        //    3)通过arguments  伪数组  接收了所有的实以
        function mycall(context) {
            // console.log(arguments);
            console.log(Array.isArray(arguments));
        }
        Function.prototype.mycall = mycall;
    })()

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" };
    let res = fn.mycall(obj, 1, 2);
    console.log(res);
</script> -->


<!-- <script>
    ; (function () {
        function mycall(context) {

            let args = [];  // 收集函数调用时的参数
            for(let i=1; i<arguments.length; i++){
                args.push(arguments[i])
            }
            console.log(args);
        }
        Function.prototype.mycall = mycall;
    })()

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" };
    let res = fn.mycall(obj, 1, 2);
    console.log(res);
</script> -->


<!-- <script>
    ; (function () {
        function mycall(context) {
            context = context ? Object(context) : window

            let args = [];  
            for (let i = 1; i < arguments.length; i++) {
                args.push(arguments[i])
            }
            console.log(args);
        }
        Function.prototype.mycall = mycall;
    })()

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" };
    let res = fn.mycall();
    // let res = fn.call("hello", 1, 2);
    // let res = fn.mycall(obj, 1, 2);
    console.log(res);
</script> -->

<!-- <script>
    ; (function () {
        function mycall(context) {
            context = context ? Object(context) : window
            // this表示  谁调用mycall，this就是谁  fn
            // this ===> fn  this();
            console.log("---");
            // this();  // 独立函数调用  fn中的this表示window  不OK
            console.log("---");
            let args = [];
            for (let i = 1; i < arguments.length; i++) {
                args.push(arguments[i])
            }
        }
        Function.prototype.mycall = mycall;
    })()

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" };
    let res = fn.mycall();
    // let res = fn.call("hello", 1, 2);
    // let res = fn.mycall(obj, 1, 2);
    console.log(res);
</script> -->

<!-- <script>
    ; (function () {
        function mycall(context) {
            context = context ? Object(context) : window
            context.f = this; // f也是指向fn函数
            let args = [];
            for (let i = 1; i < arguments.length; i++) {
                args.push(arguments[i])
            }
            let res = context.f(...args);  // 隐式绑定
            delete context.f;
            return res;
        }
        Function.prototype.mycall = mycall;
    })()

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" };
    let res = fn.mycall(obj, 1, 2);
    // let res = fn.call("hello", 1, 2);
    // let res = fn.mycall(obj, 1, 2);
    console.log(res);
</script> -->

<!-- <script>
    ; (function () {
        function mlapply(context,args) {
            context = context ? Object(context) : window;
            // this是fn  隐式绑定
            // this();  fn中的this是window
            context.f = this;
            let res = context.f(...args);
            delete context.f;
            return res;
        }
        Function.prototype.mlapply = mlapply;
    }())

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" }
    // 1）改变fn中的this指向   2）让fn执行
    let res = fn.mlapply(obj, [1, 2]);
    console.log(res);
</script> -->

<!-- <script>
    ; (function () {  // 讨论3分钟 
        function mlapply(context, args) {
            context = context ? Object(context) : window;
            context.f = this;
            let res = context.f(...args);
            delete context.f;
            return res;
        }
        Function.prototype.mlapply = mlapply;
    }())

    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    let obj = { name: "wc" }
    let res = fn.mlapply(obj, [1, 2]);
    console.log(res);
</script> -->

<!-- <script>

    function fn(num1,num2){
        console.log(this);
        return num1+num2;
    }
    // console.log(fn(1, 2));;  // 独立函数调用  函数中的this表示window

    // 显示绑定：call  apply   bind
    // 手写call的原理  手写apply的原理
    // 为什么要写？答：学习JS高级， 面试

    let obj = {name:"wc"}
    console.log(fn.apply(obj, [100, 200]));
</script> -->

<!-- <script>
    // 使用原生JS，去模拟apply的实现
    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    // 这样写，只能让fn调用mlapply
    // fn.mlapply = function(){
    //     console.log("mlapplly");
    // }
    let obj = { name: "wc" }
    console.log(fn.mlapply(obj, [100, 200]));
</script> -->

<!-- <script>
    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    Function.prototype.mlapply = function (context, args) {
        // this 表示 fn
        // this();  // 独立函数调用
        context.xxx = this;
        // 让fn中的this指向context
        return context.xxx(...args);
    }
    let obj = { name: "wc" }
    console.log(fn.mlapply(obj, [100, 200]));
</script> -->

<!-- <script>
    function fn(num1, num2) {
        console.log(this);
        return num1 + num2;
    }
    Function.prototype.mlapply = function (context, args) {
        context = context ? Object(context) : window;
        context.xxx = this;
        if (!args) {
            // 没有传递参数
            return context.xxx()
        }
        let res = context.xxx(...args);
        delete context.xxx;
        return res;
    }
    let obj = { name: "wc" }
    console.log(fn.mlapply(obj));
</script> -->

<!-- <script>
    // 封装检测数据类型的方法

    // 利用typeof检测基本类型和函数，非常准确
    console.log(typeof 123);  // number
    console.log(typeof NaN);  // number
    console.log(typeof "hello");  // string
    console.log(typeof true);  // boolean
    console.log(typeof undefined);  // undefined
    console.log(typeof function () { });  // function

    // 检测其它的，结果都是object
    console.log(typeof null);  // object
    console.log(typeof {});  // object
    console.log(typeof []);   // object
</script> -->

<!-- <script>
    // instanceof 用来检测某个对象是否属于某个类的实例
    // 123不是对象
    console.log(123 instanceof Number);  // false
    let num = new Number(123)
    console.log(num instanceof Number);  // true

    console.log({} instanceof Object);  // true
    console.log([] instanceof Array);  // true
    console.log(function(){} instanceof Function);  // true

    console.log(function(){} instanceof Object);  // true
    console.log([] instanceof Object);  // true

    // console.log(123 instanceof string);

    // instanceof 的不足：
    //   1）可以检测引用数据类型，不能检测基本数据
    //   2）所有的引用数据类型，都是Object的实例
    //   3）可以人为修改原型链，导致检测的结果不准备
</script> -->

<!-- <script>
    let n  = new Number(110);
    // 人为可以修改constructor指向 
    n.constructor = Array;
    console.log(n.constructor  === Number);  // true
    // console.log({}.constructor  === Number);  // false
    // console.log({}.constructor  === Object);  // true
    // console.log([].constructor  === Array);  // true

    // console.log(123.constructor  === Number);  // 不行

    // 不足：
    //   1）可以检测引用数据类型，不能检测基本数据类型
    //   2）人为可以修改constructor指向 ，检测的结果就不准备
</script> -->

<!-- <script>
    console.log(Object.prototype.toString.call(123)); // [object Number]
    console.log(Object.prototype.toString.call("ok")); // [object String]
    console.log(Object.prototype.toString.call(true)); // [object Boolean]
    console.log(Object.prototype.toString.call([])); // [object Array]
    console.log(Object.prototype.toString.call({})); // [object Object]
    console.log(Object.prototype.toString.call(function () { })); // [object Function]
    function Person() { }; let p = new Person();
    console.log(Object.prototype.toString.call(p)); // [object Object]
    console.log(Object.prototype.toString.call(/abc/)); // [object RegExp]
    console.log(Object.prototype.toString.call(null)); // [object Null]
    console.log(Object.prototype.toString.call(undefined)); // [object Undefined]
    let d = new Date();
    console.log(Object.prototype.toString.call(d)); // [object Date]
    let s = Symbol();
    console.log(Object.prototype.toString.call(s)); // [object Symbol]
</script> -->

<!-- <script>
    // function checkType(data) {
    //     // let type = Object.prototype.toString.call(data)

    //     // return type.slice(8, -1);

    //     // return type.substring(8,type.length-1).toLowerCase();

    //     return Object.prototype.toString.call(data).slice(8, -1).toLowerCase();
    // }

    let checkType = data => Object.prototype.toString.call(data).slice(8, -1).toLowerCase();

    // let type = checkType("hello");
    // let type = checkType(123);
    let type = checkType([]);
    console.log(type); // string  number  array
</script> -->

<!-- <script>
    let checkType = data => Object.prototype.toString.call(data).slice(8, -1).toLowerCase();
    let type = checkType("hello");
    console.log(type); 
</script> -->

<script>
    function Foo() {
        getName = function () {
            console.log(1);
        };
        return this;
    }
    Foo.getName = function () {
        console.log(2);
    };
    Foo.prototype.getName = function () {
        console.log(3);
    };
    var getName = function () {
        console.log(4);
    };

    function getName() {
        console.log(5);
    }
    Foo.getName();
    getName();
    Foo().getName();
    getName();
    new Foo.getName();
    new Foo().getName();
    // new Foo() ===> 3    und 
    // new Foo().getName();  und 
    new new Foo().getName();  // 
</script>