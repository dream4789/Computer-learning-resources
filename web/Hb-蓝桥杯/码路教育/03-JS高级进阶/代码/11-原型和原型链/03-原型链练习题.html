<!-- <script>
    function Fn() {
        this.x = 10;
        this.y = 20;
        this.getX = function () {
            console.log(this.x)
        }
    }
    Fn.prototype.getX = function () {
        console.log(this.x)
    }
    Fn.prototype.getY = function () {
        console.log(this.y)
    }
    let f1 = new Fn();
    f1.getX();
    f1.getY();
</script> -->

<!-- <script>
    function Fn(num) {
        this.x = this.y = num;
    }
    Fn.prototype = {
        x: 20,
        sum: function () {
            console.log(this.x + this.y)
        }
    }
    Fn.prototype.constructor = Fn;
    let f1 = new Fn(10)
    console.log(f1.sum === Fn.prototype.sum)
    f1.sum();
    Fn.prototype.sum();
    console.log(f1.constructor)
</script> -->

<!-- <script>
    function Person(){

    }

    // 没有new，叫函数调用 
    // Person() 在你眼中就是一个值  返回值
    // und
    let p = Person();
</script> -->

<!-- <script>
    // Person是函数
    //   函数有N种角色：
    //      角色一：普通函数
    //      角色二：方法
    //      角色三：普通对象
    //      角色四：类  推荐函数名大写    构造器  
    function Person() {
        // 1）在Person函数中创建一个空对象   {}  0x666   {a:1,b:2,c:3}
        // 2）this绑定   this = 0x666;  this指向 上面的对象
        this.a = 1;
        this.b = 2;
        this.c = 3;
        // 3）执行Person函数中的代码
        // 4）返回对象  返回0x666
    }
    // 把Person当成了一个对象  给这个对象身上添加xxx属性  值是ok
    Person.xxx = "ok";

    // new也是运算符 这个运算符的结果是对象
    // 只要你敢new，出来的100%是对象  
    let p = new Person();  // p是0x666
</script> -->

<script>
    function Fn() {
        let a = 1;
        this.a = a;
    }
    Fn.prototype.say = function () {
        this.a = 2;
    }
    Fn.prototype = new Fn();
    let f1 = new Fn();
    Fn.prototype.b = function () {
        this.a = 3;
    }
    console.log(f1.a)
    f1.say();
    console.log(f1.a)
    f1.b();
    console.log(f1.a)
</script>