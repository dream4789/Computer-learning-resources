
JS进阶作用：
    1）后面封装一个工具函数
    2）后面学习vue，react，进阶必会   
    3）看vue源码  
    4) 面试笔试必问

当你一个知识点掌握不了，说明前面的东西掌握不扎实。

后面的内容：
    ajax   vue    react   用

-----------------------------------

什么是代码段？
    答：一个script标签就是一个代码段，一个网页中可以有N人代码段，代码段执行是从上到下一个一个执行。上面代码段定义的数据（变量/函数），在下面的代码段中也可以使用。下面的代码段中定义的数据，在上面的代码段中不能使用。如果上面代码段报错，不影响下面的代码段执行，它们之前是彼此独立的。

-----------------------------------

JS代码在执行是分两个阶段：
    1）预解析  预编译
        A）加var的全局变量提升到代码段的前面
        B）全局代码中的函数整体提升到代码段最前面
        C）函数内的加var的局部变量也会提升到函数体最前面
    2）代码从上到下执行

-----------------------------------

数据存储：
    基本数据类型存储在栈区，引用数据类型存储堆区，在栈区存储堆区的地址。

-----------------------------------

全局代码和局部代码：
    当全局代码执行，就会产生全局执行上下文，当函数调用，就产生局部的执行上下文。
    执行上下文要入栈，栈也是一种数据结构，是一种先进后出的结构。

ESC: Excute Context Stack ===> ESC   里面放EC

EC的作用：
    在代码运行过程中，给代码提供数据。
    EC都有一个VO。在ECG中，VO指GO，在普通EC中，VO指AO。

GO：
    Globle Object 全局对象

VO:
    Verible Object 变量对象

AO:
    Active Object 活动对象

-----------------------------------

什么是作用域链：
    答：作用域就是数据在EC中的查找机制。.....

-----------------------------------

深入变量：
    1）加var的变量和不加var的变量有什么区别？
        A）加var的变量会提升，不加var不会提升   提升是不好的
        B）加var的变量可以是全局变量，也可以是局部变量，不加var的变量，只能是全局变量
        C）不管加不加var，只要是全局变量，都会挂载到GO上
        D）建议，不要使用加var的变量，更不使用不加var的变量，清一色使用let 

    2）使用let声明的变量有什么特点？
        A）不会提升，也有人说提升，但是没有初始化（赋值），不能访问
        B）let和{}配合形成块级作用域（重要），利用这个块级作用域可以解决很多问题
        C）不能重复声明，不会挂载到GO上

    3）使用const声明变量（常量）有什么特点？
        A）const声明的变量（常量）不能修改。 const PI = 3.14;  PI = 123; 报错了
        B）const声明的变更，在声明时，必须要赋值。 const PI; PI = 3.14; 报错了
        C）其它的特点和let一样的


-----------------------------------

高阶函数：
    如果一个函数的参数是函数，或一个函数的返回值是函数，那么这个函数叫高阶函数。

    JS中，有很多的内置的高阶函数，特别是数组中的高阶函数。

-----------------------------------

闭包：
    从形式看，要有函数嵌套，内层函数使用外层函数中的变量，让外层函数中的变量活的更久一些。
    我们也可以这样理解：一个不能被释放的栈空间，就是闭包。闭包可以让像使用全局变量那样使用局部变量。

    保护：由于闭包中的变量存在函数内部，外界不能直接访问。
    保存：延长变量的生命周期。可以让像使用全局变量那样使用局部变量。

-----------------------------------

this:
    在产生EC时，会动态给this绑定值，没有产生EC，是不能确定this是什么。
    不能给this手动赋值

this的绑定规则：
    1）默认绑定
        独立函数调用  this指window
    2）隐式绑定
        通过对象打点调用方法  方法中的this就看点前而谁
    3）显示绑定
        call apply bind  函数有对象的角色
        fn.call()  fn.apply()  fn.bind()
        call: 1）让fn执行  让fn中this指向()中的第1个参数   
        apply:  1）让fn执行  让fn中this指向()中的第1个参数
        bind: 1）不会让fn执行  返回一个绑定this后的新函数
    4）new绑定
        new做了什么？

-----------------------------------

OOP：
    一切都是对象
    对象是属性的无序集合，操作集合，CRUD
    创建对象有N种方式
        A）通过字面量的形式  
        B）工厂函数   创建出来的对象都属于Object的实例  
        C）构造器  new构造器  内存空间浪费 

-----------------------------------

公有属性和私有属性：
    let obj = { a:1,b:2,c:3 }

    每一个对象身上都有一个__proto__属性，对应的值是一个对象，这个对象叫原型对象

三角关系：
    1）每一个构造器身上都有一个prototype，显示原型
    2）每一个对象身上都有一个__proto__，隐式原型

-----------------------------------

