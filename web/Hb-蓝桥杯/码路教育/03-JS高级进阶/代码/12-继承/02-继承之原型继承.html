<!-- 
    原型链继承：改变子类的原型对象
        核心：Student.prototype = new Person();    修改子类的原型对象
        缺点：如果父中的数据是引用数据类型，子对象修改了，另一个子对象也会受影响

    父类：Person
    子类：Student
 -->

<!-- <script>
    function Person(name, age) {
        this.name = name;
        this.age = age;
        this.score = ["88", "99"];
    }
    Person.prototype.sayHello = function () {
        console.log("开始说话...");
    }

    function Student(name, age, className) {
        this.name = name;
        this.age = age;
        this.className = className;
    }
    // 改变子类的原型对象
    // new Person();  里面有：name  age  sayHello
    Student.prototype = new Person();  // 原型继承可以继承父类上的公有方法
    Student.prototype.constructor = Student;  // 手动修改constructor的指向

    Student.prototype.study = function () {
        console.log("学生在学习");
    }
    let stu = new Student("wc", 18, "h5前端1期")
    let stu2 = new Student("wc", 18, "h5前端1期")
    stu.sayHello();
    stu.score[0] = "888"
    console.log(stu.score);

    console.log(stu2.score);
</script> -->

<script>
    // 父类  
    function Person(name,age){
        this.name = name;
        this.age = age;

        this.score = ["100","100"]
    }
    // 现在：继承父类原型对象上的方法  sayHello
    Person.prototype.sayHello = function(){
        console.log("会说话...");
    }

    function Student(name,age,className){
        this.name = name;
        this.age = age;
        this.className = className;
    }
    // 原型链继承核心：改变子类的原型对象
    // Student.prototype = Person.prototype; // 地址copy 
    Student.prototype = new Person(); 
    Student.prototype.constructor = Student;

    let stu1 = new Student("wc",18,"h5一期");
    let stu2 = new Student("wc",18,"h5一期");
    console.log(stu1.name);
    console.log(stu1.age);
    console.log(stu1.className);
    stu1.sayHello();
    console.log(stu1.score);
    stu1.score[0] = 50;
    console.log(stu1.score);
    console.log(stu2.score);
</script>