<!-- <script>
    // 函数有多种角色  
    //    角色：函数也是对象   给函数这个对象上添加的属性，叫静态属性
    function Fn(){

    }
    let f = new Fn();
    Fn.age = 110; // 把Fn当成了一个对象  给这个对象上添加一个age属性
    console.log(Fn.age);
    console.log(f);
</script> -->

<!-- <script>
    class Animal{
        constructor(name,age){
            // 实例属性
            this.name = name;
            this.age = age;
        }
        // 实例方法
        running(){
            console.log("running...");
        }

        // 静态属性
        static addres = "bj"

        // 静态方法  只能通过类名去调用
        static eating(){
            console.log("eating...");
        }
    }

    let a = new Animal("wc",18);
    console.log(a);
    a.running();
    // a.eating();
    Animal.eating();
    console.log(Animal.addres);
</script> -->

<!-- <script>
    class Person{
        constructor(name,age){
            this.name = name;
            this.age = age;
        }
        running(){
            console.log("running....");
        }
        static eating(){
            console.log("eating...");
        }
    }
    class Student extends Person{
        constructor(name,age,sno){
            super(name,age)
            this.sno = sno;
        }
    }
    let stu = new Student("wc",18,"001");
    stu.running();
    // stu.eating();
    Student.eating(); // 通过子类的类名也可以调用父类的静态方法
</script> -->

<!-- <script>
    class Person {
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
        running() {
            console.log("父的 running....");
        }
        static eating() {
            console.log("eating...");
        }
    }
    class Student extends Person {
        constructor(name, age, sno) {
            super(name, age)
            this.sno = sno;
        }
        // 方法的重写   子类重写父类中的同名方法
        // 调用时，肯定是调用自己的
        // 需求：在子类的running中调用父类的runing
        running(){
            super.running();
            console.log("子的 running");
        }
    }
    let stu = new Student("wc", 18, "001");
    stu.running();
</script> -->

<script>
    // 自己的类，去继承内置类
    class MyArray extends Array {
        // 方法的重写   调用时，只会调用自己的push
        push(data) {
            super.push(data)
            console.log("我的push");
        }
    }

    let marr = new MyArray();
    marr.push(1)
    marr.push(2)
    marr.push(3)

    console.log(marr);
</script>