<!-- <script>
    // Object.assign()
    let obj1 = { name: "wc", score: 88 }
    let obj2 = { age: 18, address: "bj" }

    let obj3 = {}

    for (let key in obj1) {
        obj3[key] = obj1[key];
    }
    for (let key in obj2) {
        obj3[key] = obj2[key];
    }
    console.log(obj3);
</script> -->

<!-- <script>
    // Object.assign()
    let obj1 = { name: "wc", score: 88 }
    let obj2 = { age: 18, address: "bj" }

    let obj3 = {};
    // 第1个参数表示目标对象
    // 从第2个参数开始，后面的所有的参数都是源对象
    Object.assign(obj3,obj1,obj2);
    console.log(obj3);
</script> -->

<!-- <script>
    // Object.assign()   
    // 如果是引用数据类型 Object.assign是浅copy
    let obj1 = { name: "wc", address:{ city:"bj" } }

    let obj3 = {};
    Object.assign(obj3, obj1);
    console.log(obj3);

    console.log("-------------");
    obj1.address.city = "sh";
    console.log(obj3);
</script> -->

<!-- <script>
    // call stack 调用栈  ECS
    // RangeError: Maximum call stack size exceeded
    function test(){
        test()
    }
    test();
</script> -->

<!-- <script>
    // 封装一个可以实现深copy的方法
    function deepClone(source) {
        let newObj = {};
        for(let key in source){
            if(typeof source[key] == "object"){
                newObj[key] = deepClone(source[key])
            }else{
                newObj[key] = source[key]
            }
        }
        return newObj;
    }
    let obj1 = { name: "wc", address: { city: "bj" } }
    let obj2 = deepClone(obj1);
    obj1.address.city = "sh";
    console.log(obj2.address.city); // bj
</script> -->