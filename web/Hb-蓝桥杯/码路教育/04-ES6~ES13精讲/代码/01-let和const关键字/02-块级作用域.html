<!-- <script>
    // 为什么需要块级作用域？
    var t = new Date(); // 日期对象
    function foo(){
        console.log("t=",t);
        if(false){
            // var t 会提升  提升到函数体的最前面
            // 同名局部变量会覆盖全局变量
            var t = "hello es6"
        }
    }
    foo();
</script> -->

<!-- <script>
    // 循环都结束了，但是循环变量还可以使用
    // 我们希望循环结束后，循环变量是不能使用的
    for (var i = 0; i <= 10; i++) {
        console.log("i=", i);
    }
    console.log("------");
    console.log("last i=", i);
</script> -->


<!-- <script>
    let t = new Date();
    function foo() {
        // 找t 在函数的作用域中找不到的
        // 去父的EC中找，找到了  t是一个日期
        console.log("t=", t);
        if (false) {
            // let声明的变量不会提升
            // let和 if对应的{}形成块给作用域
            // 在这个块级作用域之外，是得不到下面的t
            let t = "hello es6"
        }
    }
    foo();
</script> -->

<!-- <script>
    function bar() {
        // let + {} 也形成了块级作用域 
        let num = 5;
        if (true) {
            // let + {} 形成块级作用域
            // 里面的块级作用域，只能针对里面有效
            let num = 10;
        }
        // 找num  
        console.log(num);
    }
    bar();
</script> -->

<!-- <script>
    if(true){
        let b = 20;
        console.log(b);
        if(true){
            // 出了这个{}  就没有c
            let c = 30
        }
        // 报错了  ReferenceError: c is not defined
        console.log(c);
    }
</script> -->

<!-- <script>
    // t是一个全局变量
    // let t = "hello es6"
    // console.log(t);

    ; (function () {
        // 即使使用了var  但是var t 是写在函数中的
        // 形成局部作用域，不会污染全局
        var t = "hello es6"
        console.log(t);
    }())

    var t = 666;
    console.log(t);
</script> -->

<!-- <script>
    // 现在要形成一个独立的作用域，只需要使用{}就OK
    // 后面看到一个{}不能直接说是一个对象
    {
        let t = "hello es6";
        console.log(t);
    }

    let t = 888;
    console.log(t);
</script> -->

<!-- <script>
    let t = "hello";

    {
        // {} + let已经形成了块级作用域
        // let 是不能提升的
        // ReferenceError: Cannot access 't' before initialization
        // 暂存性死区
        console.log("t=", t);
        let t = "world";
    }
</script> -->

<!-- <script>
    // for循环是同步代码
    for(var i=1; i<=3; i++){
        // setTimeout是异步代码
        setTimeout(function(){
            console.log("i=",i);
        },1000)
    }

    // 同步代码执行完毕后，才会执行异步代码
</script> -->

<!-- <script>
    for (var i = 1; i <= 3; i++) {
        (function(i){
            setTimeout(function () {
                console.log("i=", i);
            }, 1000)
        })(i)
    }
</script> -->

<script>
    for (let i = 1; i <= 3; i++) {
        setTimeout(function () {
            console.log("i=", i);
        }, 1000)
    }
</script>