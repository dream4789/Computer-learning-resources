<script>
    // number类型
    //   不管是小数，还是整数，在JS中统一叫number

    // 一般写的number都是10进制
    // var num1 = 110;
    // console.log(num1);

    // 8进制   0~7   逢8进1
    // var num1 = 024;  // 以0打头表示8进制
    // console.log(num1); // 20  log出来的是10进制

    // var num1 = 079;  // 这样写，就不是8进制，超过7就不属于8进制了，直接按10进制处理
    // console.log(num1); // 79

    // 16进制  0~9  a~f  a:10  b:11  c:12  f:15
    // var num1 = 0x2a;
    // console.log(num1); // 42

    // Uncaught SyntaxError: Invalid or unexpected token
    // SyntaxError  叫语法错误  语法错误是最好找的错误
    // var num1 = 0x5h;
    // console.log(num1);
</script>

<!-- =========================== -->

<script>
    // Number函数
    // 用于把其它类型转化成Nubmer类型

    // console.log(Number(10)); // 10
    // console.log(Number(010));   // 8
    // console.log(Number(0x10));   // 16

    // console.log(Number(true));  // true转number得到1
    // console.log(Number(false));  // false转number得到0

    // console.log(Number(null)); //  0

    // console.log(Number(undefined)); // NaN

    // console.log(Number("110"));  // 110
    // console.log(Number("010"));  // 10  去掉前面的0
    // console.log(Number("0x12"));  // 18

    // console.log(Number(""));   // 0
    // console.log(Number("     "));  // 0
    // console.log(Number("abc"));  // NaN
    // console.log(Number("123abc"));  // NaN
</script>

<!-- =========================== -->

<script>
    // 对象是属性的无序集合
    // 你的肉眼看到这里面没有属性
    // 实际上这里面有非常多的属性
    // 当你尝试把obj转化成Number是，它会尝试调用obj中的valueOf函数
    // var obj = {};
    // console.log(obj.valueOf);

    // console.log(obj);

    // console.log(Number(obj));
</script>

<!-- =========================== -->

<script>
    // var obj = {
    //     valueOf:function(){
    //         console.log("valueOf...");
    //         return 123
    //     }
    // };
    // // 这里调用的是自己的valueOf
    // // 打点去调用时，如果自己有，就不会再沿着原型链去原形对象上找了
    // console.log(obj.valueOf());
</script>

<!-- =========================== -->

<script>
    // var obj = {
    //     num1:110,
    //     // 谁去调用valueOf，那么valueOf中的this就是谁
    //     valueOf: function () {
    //         return this.num1
    //     }
    // };
    // obj去调用了，那么valueOf中的this表示obj
    // console.log(obj.valueOf());

    // 当把一个对象尝试转化成number时，会自动调用对象的valueOf函数
    // valueOf函数，返回的数字，就是转化后的数字
    // console.log(Number(obj));
</script>

<!-- =========================== -->

<script>
    // 如果没有重写valueOf函数，那么它会调用toString函数
    // var obj = {
    //     num1: 110,
    //     toString:function(){
    //         return this.num1;
    //     }
    // };
    // console.log(Number(obj));
</script>

<!-- =========================== -->

<script>
    // var obj = {
    //     valueOf: function () {
    //         return 666
    //     },
    //     toString: function () {
    //         return 888
    //     }
    // };
    // console.log(Number(obj));
</script>

<!-- =========================== -->

<script>
    // string 字符串   redix是进制
    // 作用：尝试把一个字符串转化成数字
    //    如果第一个参数不是字符串，也会尝试转化成字符串
    //    第二个参数表示进制  二进制  十进制  八进制  十六进制，如果不写，默认是10进制
    // parentInt(string,redix)

    // 如果字符串转化不成，结果是NaN
    // console.log(parseInt("aaa"));

    // 把字符串去转时，先从第1个字符开始，
    // 第1个字符是f，f是可以转在16进制的  f --->  15
    // 看第2个字符  是 g  转化不成功  后面的所有字符，就停止转化
    // console.log(parseInt("fg123",16));

    // 先从第1个字符开始转，默认进制是10进制
    // 1  6都可以转  *不能转  后面字符就停止转化
    // console.log(parseInt("16*2")); // 16

    // 先运算16*2 得到32 把32转成字符串  然后再转成数字
    // console.log(parseInt(16 * 2));

    // 3.1415926 先隐式转化成字符串 "3.1415926"
    // console.log(parseInt(3.1415926));

    // var arr = ["1", "2", "3", "4"];
    // function parseInt(string,indix){  }
    // parseInt是JS内置好的函数
    // var res = arr.map(parseInt);
    // var res = arr.map(function(string,indix){
        // string表示第一项   index表示索引  0 1 2 3
        // 1 ===> 0   把字符串1尝试转成数字 0进制     1
        // 2 ===> 1   把字符串2尝试转成数字 1进制   没有1进制  转化失败  NaN
        // 3 ===> 2   把字符串3尝试转成数字 2进制   3转化成2进制，失败 NaN
        // 4 ===> 3   把字符串4尝试转成数字 4进制   4转化成3进制，失败 NaN
    // });
    // console.log(res);  // [1, NaN, NaN, NaN]
</script>

<!-- =========================== -->

<!-- <script>
    var arr1 = [1, 2, 3, 4];
    // map可以对数组中的元素进行加工
    // item表示数组中的每一个元素,不要问为什么，这种编程方式叫声明式编程
    // 你只需要按人家的规则写代码
    // map返回一个加工后的新数组
    let newArr = arr1.map(function (item,index) {
        return item * item
    });
    console.log(newArr);
</script> -->

<!-- =========================== -->

<!-- <script>
    // function fn(a,b){
    //     return a+b;
    // }
    // console.log(fn(1,2));

    // cb callback 是回调的意思
    // cb 形参
    function fn(cb) {
        // console.log(cb(1, 2));

        return cb(1, 2)
    }
    // function(){} 叫实参
    console.log(fn(function (a, b) {
        return a + b;
    }));
</script> -->

<!-- =========================== -->

<!-- <script>
    var arr = ["1", "1", "1", "1"];
    var res = arr.map(parseInt); // 1 NaN 1  1
    console.log(res);
</script> -->

<!-- =========================== -->

<script>
    // parseFloat(string);
    // 没有进制的概念  尝试把一个字符串转化成小数
    // 如果转化不成功，得到NaN
    // 也是一位一位转，如果某一位不成功，后面就不转化了
    // 如果遇到空格直接忽略了
    // 对于第1个点，会解析，后面的.就不会解析了，后面就不转化了

    // console.log(parseFloat("2.111")); // 2.111
    // console.log(parseFloat("2.1abc1")); // 2.1
    // console.log(parseFloat("  2.1")); // 2.1
    // console.log(parseFloat("a2.1")); // NaN
    // console.log(parseFloat("2.1.2.3")); // 2.1
</script>

<!-- =========================== -->

<script>
    // 把字符串，转化成数字，有三种方案：
    //   1）Number
    //      特点：转化的是整体，转化不成功，得到NaN
    //   2）parseInt  parseFloat
    //      特点：一个字符，一个字符去转，直到某个字符转化失败，停止转化
    //      parseInt转时，有进制的概念，parseFloat没有进制的概念
</script>

<!-- =========================== -->


<!-- <script>
    // isNaN  用于判断一个数据是否是NaN
    // 是ES5中提供的，但是是有问题的

    // var a = "hello" * 10;
    // console.log(a);

    // console.log(isNaN(a));  // true

    console.log(isNaN(NaN));; // true
    // 会把und转化成数字，发生了隐式类型转化 und转化成数字是NaN
    console.log(isNaN(undefined));; // true
    console.log(isNaN({}));; // true
    // 要把传入的数据转化成数字
    console.log(isNaN(true));; // false true===>1
    console.log(isNaN(false));; // false
    console.log(isNaN(null));; // false
    console.log(isNaN(1));; // false
    console.log(isNaN("abc"));; // true  abc转数字是NaN
    console.log(isNaN("123"));; // false
    console.log(Number(null));  // 0
</script> -->

<!-- =========================== -->

<script>
    // 在ES6中，在Number.isNaN(),
    // 判断一个数据是否是NaN，这里不会发生类型转化

    console.log(Number.isNaN(NaN));
    console.log(Number.isNaN({}));
    console.log(Number.isNaN("abc"));

    // ES5: isNaN()  会发生隐式类型转化
    // ES6：Number.isNaN()  不会发生隐式类型转化
    // 后面我们判断一个数字是否是NaN,使用：Number.isNaN()
</script>